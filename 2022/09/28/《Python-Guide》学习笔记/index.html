<!--
	作者：Sariay
	时间：2018-08-26
	描述：There may be a bug, but don't worry, Qiling(器灵) says that it can work normally! aha!
-->
<!DOCTYPE html>
<html class="html-loading">
		

<head>
	<meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <title>
    
      《Python Guide》学习笔记 | Archeri&#39;s Blog
    
  </title>
  <meta name="author" content="Archeri Shade">
  <meta name="keywords" content="" />
  <meta name="description" content="" />
	<!-- favicon -->
  <link rel="shortcut icon" href="/img/favicon.ico">

  <!-- css -->
  
<link rel="stylesheet" href="/css/Annie.css">

  
  <!-- jquery -->
	
<script src="/plugin/jquery/jquery.min.js"></script>


<script>
    const CONFIG_BGIMAGE = {
      mode: 'random_you',
      normalSrc: '/img/header-bg.jpg',
      randomYouMax: 7,
      randomYouSrc: '/img/Random-img/',
	  randomOtherSrc: 'https://api.berryapi.net/?service=App.Bing.Images&day=-0',
	  preloaderEnable: true
    }
	
    const CONFIG_LEACLOUD_COUNT = {
      enable: false,
	  appId: 'AU8...',
	  appKey: '4cU...',
	  serverURLs: 'http' || ' '
    }
  </script>
<meta name="generator" content="Hexo 7.3.0"></head>
	<body>
		<!-- Preloader -->

	<div id="preloader">
		<div class="pre-container">
			
				<div class="spinner">
					<div class="double-bounce1"></div>
					<div class="double-bounce2"></div>
				</div>
						
		</div>
	</div>


<!-- header -->
<header class="fixbackground bg-pan-br">
	<div class="mask">
		<!-- motto -->
		<div class="h-body">	
			
				<div class="motto text-shadow-pop-left">
					<p class="content" id="motto-content">获取中...</p>
					<p>-<p>
					<p class="author" id="motto-author">Just a minute...</p>
				</div>
			
		</div>
		
		<!-- others: such as time... -->			
		<div class="h-footer">
			<a href="javascript:;" id="read-more" class="scroll-down">
				<span class="icon-anchor1 animation-scroll-down"></span>
			</a>
		</div>
	</div>
</header>

<div id="navigation-hide">
	<!-- Progress bar -->
	<div id="progress-bar"></div>

	<!-- Progress percent -->
	<div id="progress-percentage"><span>0.0%</span></div>

	<div class="toc-switch"><span class="switch-button">目录</span></div>

	<!-- Page title -->
	<p>
		
			「《Python Guide》学习笔记」
		
	</p>

	
	

	<!-- Nav trigger for navigation-H-->
	<a class="nav-trigger"><span></span></a>
</div>

<!-- Navigation in div(id="navigation-H") -->
<nav class="nav-container" id="cd-nav">
	<div class="nav-header">
		<span class="logo"> 
			<img src="/img/logo.png">
		</span>
		<a href="javascript:;" class="nav-close"></a>
	</div>
	
	<div class="nav-body">
		<ul id="global-nav">
	
		<li class="menu-home">
			<a href="/" class="menu-item-home" target="_blank">主页</a>
		</li>
		
	
		<li class="menu-archive">
			<a href="/archives" class="menu-item-archive" target="_blank">归档</a>
		</li>
		
	
		<li class="menu-categories">
			<a href="/categories" class="menu-item-categories" target="_blank">分类</a>
		</li>
		
	
		<li class="menu-tags">
			<a href="/tags" class="menu-item-tags" target="_blank">标签</a>
		</li>
		
	
		<li class="menu-about">
			<a href="/about" class="menu-item-about" target="_blank">关于</a>
		</li>
		
	
		<li class="menu-gallery">
			<a href="/gallery" class="menu-item-gallery" target="_blank">相册</a>
		</li>
		
	

	
		<li class="menu-search">
			<a href="javascript:;" class="popup-trigger">搜索</a>
		</li>
	
</ul>
	</div>
	
	<div class="nav-footer">
		<ul id="global-social">
	
		<li>
			<a href="https://github.com/ArcheriShade" target="_blank">
				<span class="icon-github"></span>
			</a>
		</li>
			
</ul>

	</div>
</nav>
			
		<!--main-->
		<main>
			<!--
	时间：2018-11-17
	描述：
		插件名称：katelog.min.js
		插件作者：KELEN
		插件来源: https://github.com/KELEN/katelog
-->

	
		<div class="layout-toc">
			<div id="layout-toc">
				<div class="k-catelog-list" id="catelog-list" data-title="文章目录"></div>
			</div>
		</div>

		
<script src="/plugin/toc/katelog.min.js"></script>


		
	 

<div class="layout-post">
	<div id="layout-post">
		<div class="article-title">
			
	<a href="/2022/09/28/%E3%80%8APython-Guide%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url">
		《Python Guide》学习笔记
	</a>

		</div>

		<div class="article-meta">
			<span>
				<i class="icon-calendar1"></i>
				
				




	更新于

	<a href="/2022/09/28/%E3%80%8APython-Guide%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url">
		<time datetime="2022-09-28T05:29:02.000Z" itemprop="dateUpdated">
	  		2022-09-28
	  </time>
	</a> 



			</span>
			<span>
				
	<i class="icon-price-tags"></i>
	
		<a href="/tags/Python/" class=" ">
			Python
		</a>
	
		<a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" class=" ">
			编程语言
		</a>
	
		
			</span>
			
			



		</div>

		<div class="article-content" id="article-content">
			<h1 id="NOTE-Python-Guide-v1-0"><a href="#NOTE-Python-Guide-v1-0" class="headerlink" title="[NOTE] Python Guide v1.0"></a>[NOTE] Python Guide v1.0</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>是对王炳明-Python Guide v1.0的学习笔记</p>
<p>已经有一些Python基础<br>但还是觉得没有系统化地构筑自己的知识库<br>（要啥自己的知识库，直接翻官方文档不就好了吗）<br>练习也偏少<br>因此重头来过<br>会的快速过，不太熟的记一记练一练，不会的认真学</p>
<p>每一大章即使没有内容都会写一下<br>小章有就记，没有就不记</p>
<p>之前的Python环境是3.9.7，装饰器及后面换成3.10</p>
<p>感觉后面还是再过一遍Python 3.10的官方文档比较好<br><del>（但是好像没有涉及到像装饰器这样的进阶内容？）</del><br>（算了算了，官方文档深究下去就像无底深渊。。。。）</p>
<h2 id="第一章-安装运行"><a href="#第一章-安装运行" class="headerlink" title="第一章 安装运行"></a>第一章 安装运行</h2><p>水</p>
<h2 id="第二章-数据类型"><a href="#第二章-数据类型" class="headerlink" title="第二章 数据类型"></a>第二章 数据类型</h2><h3 id="2-1-常量与变量"><a href="#2-1-常量与变量" class="headerlink" title="2.1 常量与变量"></a>2.1 常量与变量</h3><p>新的变量只有通过<strong>赋值</strong>，才会占据内存空间并被创建</p>
<p>分别赋值的方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>通过id()函数获取变量内存地址<br>从而判断变量名是否指向同一对象<br><strong>变量</strong> &amp; <strong>对象</strong></p>
<h3 id="2-2-字符串类型"><a href="#2-2-字符串类型" class="headerlink" title="2.2 字符串类型"></a>2.2 字符串类型</h3><p><strong>Python没有字符对象</strong>，单个字符也当作字符串对象</p>
<p>判断字符串是否以某字符串开头&#x2F;结尾的两个函数：</p>
<ul>
<li>string.startswith(“something”)</li>
<li>string.endswith(“something”)</li>
</ul>
<p>格式化字符串的另一种方法<strong>（仅Python 3.9支持）</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;Archeri&quot;</span></span><br><span class="line">msg = <span class="string">f&quot;hello <span class="subst">&#123;name&#125;</span>&quot;</span>	<span class="comment"># 字符串前加‘f’，然后就会自动绑定变量</span></span><br></pre></td></tr></table></figure>

<p>以某模式分割字符串的方法：string.split()</p>
<h3 id="2-3-数字类型"><a href="#2-3-数字类型" class="headerlink" title="2.3 数字类型"></a>2.3 数字类型</h3><p>实际上Python还支持复数（然而很少用到）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span> + <span class="number">0.2j</span></span><br><span class="line">b = <span class="built_in">complex</span>(<span class="number">10</span>, <span class="number">0.2</span>)</span><br></pre></td></tr></table></figure>

<p>除法取整：a &#x2F;&#x2F; b<br>除法取余：a % b<br>幂运算：a**b<br>数值四舍五入：round(a)</p>
<h3 id="2-5-学会输入与输出"><a href="#2-5-学会输入与输出" class="headerlink" title="2.5 学会输入与输出"></a>2.5 学会输入与输出</h3><p>input()函数：总是把用户输入作为<strong>字符串</strong><br>有时候可以用于<strong>阻塞或暂停程序</strong>：<br><code>input(&quot;请按回车键继续……&quot;)</code></p>
<hr>
<p>print()函数可以接受多个字符串，输出时会自动用空格隔开各字符串<br>而使用“+”链接字符串，则是需要先计算字符串相加的结果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">&quot;i am&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">&quot;Archeri&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(a, <span class="string">&quot;a&quot;</span>, b)</span><br><span class="line">i am a Archeri</span><br></pre></td></tr></table></figure>

<p>其中有<strong>两个参数</strong>：</p>
<ul>
<li>sep：设定分隔的符号，默认为空格</li>
<li>end：设定输出结束方式，默认为‘\n’</li>
</ul>
<h3 id="2-6-字符串格式化"><a href="#2-6-字符串格式化" class="headerlink" title="2.6 字符串格式化"></a>2.6 字符串格式化</h3><p>三种方式：</p>
<ul>
<li><p>使用%占位符进行格式化</p>
</li>
<li><p>使用format()函数进行格式化</p>
</li>
<li><p>使用f-string进行格式化（Python3.9+）</p>
</li>
</ul>
<hr>
<p>其中format()函数还支持“格式限定符”</p>
<p>语法：<strong>‘{}’中带‘:’号</strong></p>
<p><strong>填充与对其</strong><br>:号后面带填充的字符，只能是一个字符，不指定的话默认是用空格填充<br>^、&lt;、&gt;分别是居中、左对齐、右对齐，后面带宽度<br>例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;:&gt;8&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;     123&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;:X&gt;8&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;XXXXX123&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;:X^8&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;XX123XXX&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;i am &#123;name:#^16&#125;&quot;</span>.<span class="built_in">format</span>(name=<span class="string">&quot;Archeri&quot;</span>)</span><br><span class="line"><span class="string">&#x27;i am ####Archeri#####&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>精度与类型f</strong></p>
<p>例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;:.2f&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">123.456</span>)</span><br><span class="line"><span class="string">&#x27;123.46&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>进制转换</strong></p>
<p>使用{:b}、{:d}、{:o}、{:x}<br>分别把数字转换为二进制、十进制、八进制以及十六进制输出</p>
<p><strong>千位分隔符</strong></p>
<p>‘,’能做千位分隔符，常用于长整数显示，例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&#123;:,&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">1234567890</span>)</span><br><span class="line"><span class="string">&#x27;1,234,567,890&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="第三章-数据结构"><a href="#第三章-数据结构" class="headerlink" title="第三章 数据结构"></a>第三章 数据结构</h2><h3 id="3-1-列表"><a href="#3-1-列表" class="headerlink" title="3.1 列表"></a>3.1 列表</h3><p>实例化一个列表的方法：<br><code>ls = list()</code><br>然后一般推荐直接使用中括号创建列表</p>
<p>已知元素检索元素位置的方法：<br><code>ls.index(&quot;something&quot;)</code></p>
<p>计算列表中某元素个数的方法：<br><code>ls.count(&quot;something&quot;)</code></p>
<p>列表拼接方法（在<code>ls1</code>上改变，返回<code>None</code>）：<br><code>ls1.extend(ls2)</code></p>
<p>方法remove()和pop()的区别：根据元素内容&#x2F;元素位置删除</p>
<p>clear()方法只能清空元素，del语句能删除指定元素：<br><code>ls.clear()</code><br><code>del ls[1:3]</code></p>
<p>列表反转的两种方法：</p>
<ul>
<li>ls.reverse()：原对象反转</li>
<li>ls[::-1]：切片反转，返回新对象</li>
</ul>
<h3 id="3-2-元组"><a href="#3-2-元组" class="headerlink" title="3.2 元组"></a>3.2 元组</h3><p>元组不可变，而列表可变</p>
<p>创建元组时，圆括号可有可无：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>实例化一个元组的方法：<br><code>a = tuple()</code><br>然后一般推荐直接使用圆括号创建元组</p>
<h3 id="3-3-字典"><a href="#3-3-字典" class="headerlink" title="3.3 字典"></a>3.3 字典</h3><p>我少见的构造字典的方法：</p>
<ul>
<li><code>dic = dict(name=&quot;Archeri&quot;, age=22)</code></li>
<li><code>dic = dict([(&#39;name&#39;,&#39;Archeri&#39;), (&#39;age&#39;,22)])</code></li>
<li><code>dic = &#123;x:x**2 for x in (2,4,6)&#125;</code></li>
</ul>
<p>已知key获取value的两种方法：</p>
<ul>
<li>直接dic[‘key’]，若不存在则<strong>报错</strong></li>
<li>dic.get(‘key’)，若不存在则<strong>返回None型</strong><br>补充：None型用“is”&#x2F;“is not”判断</li>
</ul>
<p>一般使用del语句删除字典中的元素：<br><code>del dic[&#39;key&#39;]</code></p>
<p>一般使用in&#x2F;not in来判断某key是否存在于字典中：<br><code>&#39;key&#39; in dic</code></p>
<h3 id="3-4-集合"><a href="#3-4-集合" class="headerlink" title="3.4 集合"></a>3.4 集合</h3><p><strong>无序</strong>，<strong>不重复</strong><br>无序意味着元素没有索引，所以集合只有添加&#x2F;删除元素</p>
<p>创建方法：</p>
<ul>
<li>直接使用花括号创建，自动去重<br><code>a = &#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;&#125;</code><br>（有冒号就成了键值对，成了字典）</li>
<li>使用set()函数创建，可传入列表作为参数</li>
</ul>
<p>使用add()方法来向集合中添加元素</p>
<p>删除元素的方法：</p>
<ul>
<li>a.remove(“something”)，若不存在则<strong>报错</strong></li>
<li>a.discard(“something”)，若不存在也<strong>不会报错</strong>（返回<code>None</code>）</li>
<li>a.pop()，<strong>随机</strong>删除一个元素</li>
<li>a.clear()，清空集合元素</li>
</ul>
<hr>
<p><strong>集合运算</strong></p>
<p>求并集：<br><code>aset.union(bset)</code></p>
<p>求差集：<br><code>aset.difference(bset)</code><br><code>aset - bset</code><br>（也有类似下面的_update版本）</p>
<p>求交集：<br><code>aset.intersection(bset)</code><br><code>aset &amp; bset</code><br><code>aset.intersection_update(bset)</code><br>前两个返回交集，第三个原地更新到aset上</p>
<p>求不重合集：<br><code>aset.symmetric_difference(bset)</code><br><code>aset.symmetric_difference_update(bset)</code><br>第一个返回不重合集，第二个原地更新到aset上</p>
<p>判断是否有交集：<br><code>aset.isdisjoint(bset)</code></p>
<p>判断bset是否为aset的子集：<br><code>bset.issubset(aset)</code><br>（判断是否为超集issuperset()）</p>
<h3 id="3-5-迭代器"><a href="#3-5-迭代器" class="headerlink" title="3.5 迭代器"></a>3.5 迭代器</h3><p>可利用for循环的对象都叫做可迭代对象<br>如列表、元组、字典和字符串等</p>
<p>一般用isinstance()函数判断一个对象是否为可迭代：<br><code>isinstance(&#123;对象&#125;, Iterable)</code><br>然而这样不是百分百准确，最好用for循环</p>
<hr>
<p><strong>可迭代对象</strong></p>
<p><strong>第一种场景</strong>：<br>如果一个对象内部实现了 __iter__()方法，并返回一个迭代器实例，那么该对象<br>就是可迭代对象<br>使用isinstance()判断是不是<code>Iterable</code>，判断为True<br>可以使用for循环遍历</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span>:</span><br><span class="line">    mylist = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iter</span>(<span class="variable language_">self</span>.mylist)</span><br></pre></td></tr></table></figure>

<p><strong>第二种场景</strong></p>
<p>假如对象没有实现__iter__()，但Python解释器可以用o__getitem()__方法获取元素，则该对象也是可迭代对象<br>但使用isinstance()，判断为False<br>可以使用for循环遍历</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span>:</span><br><span class="line">    mylist = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.mylist[item]</span><br></pre></td></tr></table></figure>

<p>所以使用isinstance()去判断是否可迭代<br>实际上是判断对象是否有__iter__()方法<br>作为判断是否为可迭代对象并不准确</p>
<hr>
<p><strong>迭代器</strong></p>
<p>对一个可迭代对象使用iter()函数后，会返回一个迭代器对象<br>对于迭代器对象，可使用next()函数去获取其中的一个元素<br>直到元素被全部获取完，再调用next()函数会抛出StopIteration异常</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="built_in">iter</span>(ls)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(a)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(a)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(a)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>

<p>对比可迭代对象，迭代器内部只是多了一个__next()__方法<br>因此可以使用next()函数来获取元素</p>
<p>因此可以自己<strong>自定义可迭代对象</strong>，并以此为基础<strong>创建迭代器</strong></p>
<h3 id="3-6-生成器"><a href="#3-6-生成器" class="headerlink" title="3.6 生成器"></a>3.6 生成器</h3><p>Generator<br>是一个可以像迭代器那样使用for循环来获取元素的<strong>函数</strong><br>实现了<strong>延时计算</strong>，从而缓解了在大量数据下内存消耗过猛的问题<br>（懒加载？？需要计算时才占用内存？）<br>要是下次有大数组，可以考虑不直接生成占用内存，而是使用生成器</p>
<p>简单例子（注意是用圆括号生成）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen = (i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen</span><br><span class="line">&lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x0000025207997F90</span>&gt;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>yield</strong></p>
<p>有点像函数里的return，但是又有点不同</p>
<ul>
<li>函数运行到yield后会暂停，并返回yield的值</li>
<li>若yield没有任何值就返回None</li>
<li>返回后函数并没有结束</li>
</ul>
<p>如下定义generator_factory()函数，gen在这里是一个生成器对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">generator_factory</span>(<span class="params">top=<span class="number">5</span></span>):</span><br><span class="line"><span class="meta">... </span>    index = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> index &lt; top:</span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(<span class="string">&quot;index: &quot;</span> + <span class="built_in">str</span>(index))</span><br><span class="line"><span class="meta">... </span>        index = index + <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">yield</span> index</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">raise</span> StopIteration</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen = generator_factory()</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>生成器的使用</strong></p>
<p>想要从生成器对象中取出元素，有以下方法：</p>
<p><strong>第一种方法</strong>：<br>使用next(gen)函数地把元素依次取出来，直到取完，生成器抛出StopIteration异常</p>
<p><strong>第二种方法</strong>：<br>使用for循环一个个迭代出来<br><code>for x in gen: pass</code></p>
<p><strong>第三种方法</strong>：<br>使用gen.send(None)方法，相当于next(gen)</p>
<hr>
<p><strong>生成器的状态</strong></p>
<ul>
<li>GEN_CREATED：已创建，尚未激活</li>
<li>GEN_RUNNING：正在被解释器执行（多线程应用中出现）</li>
<li>GEN_SUSPENDED：在yield表达式处暂停</li>
<li>GEN_CLOSED：执行结束</li>
</ul>
<p>可以通过下面的方式查看生成器状态：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> inspect <span class="keyword">import</span> getgeneratorstate</span><br><span class="line">getgeneratorstate(gen)</span><br></pre></td></tr></table></figure>

<h2 id="第四章-控制流程"><a href="#第四章-控制流程" class="headerlink" title="第四章 控制流程"></a>第四章 控制流程</h2><h3 id="4-2-循环语句"><a href="#4-2-循环语句" class="headerlink" title="4.2 循环语句"></a>4.2 循环语句</h3><p><strong>带索引循环</strong></p>
<p>可以通过作用enumerate()函数，在for循环时把索引也取出来：<br>（下次就不要写什么另外用一个变量来指示序号了）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls = [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> i,char <span class="keyword">in</span> <span class="built_in">enumerate</span>(ls):</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;No.&#123;&#125; is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(i+<span class="number">1</span>, char)) </span><br></pre></td></tr></table></figure>

<p><strong>for-else循环&#x2F;while-else循环</strong></p>
<p>在for&#x2F;while循环后面添加else分支，当for&#x2F;while循环体中正常执行完毕之后（即没有中途break），将自动执行else分支</p>
<h3 id="4-4-推导式"><a href="#4-4-推导式" class="headerlink" title="4.4 推导式"></a>4.4 推导式</h3><p>总共有4种推导式：</p>
<ol>
<li>列表推导式——方括号</li>
<li>字典推导式——花括号+键值对</li>
<li>集合推导式——花括号</li>
<li>生成器推导式——圆括号</li>
</ol>
<hr>
<p><strong>列表推导式</strong></p>
<p>new_list &#x3D; [expression for_loop_expression if condition]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>字典推导式</strong></p>
<p>new_dict &#x3D;{ key_expr: value_expr for_loop_expression if condition }</p>
<p><img src="/2022/09/28/%E3%80%8APython-Guide%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211015162649413.png" alt="image-20211015162649413"></p>
<hr>
<p><strong>集合推导式</strong></p>
<p>new_set &#x3D; { expr for_loop_expression if condition }</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = &#123;i <span class="keyword">for</span> i <span class="keyword">in</span> a&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>生成器推导式</strong></p>
<p>new_gen &#x3D; (expression for_loop_expression if condition)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen = (i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen</span><br><span class="line">&lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x0000023E1F107F90</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="第五章-学习函数"><a href="#第五章-学习函数" class="headerlink" title="第五章 学习函数"></a>第五章 学习函数</h2><h3 id="5-2-函数参数"><a href="#5-2-函数参数" class="headerlink" title="5.2 函数参数"></a>5.2 函数参数</h3><p>函数参数传递的是实际对象的<strong>内存地址</strong></p>
<p>一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;传进来的a&quot;</span>, a, <span class="built_in">id</span>(a))</span><br><span class="line">    a = a + <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;函数内部加一后的a&quot;</span>, a, <span class="built_in">id</span>(a))</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;原始的a&quot;</span>, a, <span class="built_in">id</span>(a))</span><br><span class="line">func(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;经过函数变化后的a&quot;</span>, a, <span class="built_in">id</span>(a))</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原始的a 1 1754898956528</span><br><span class="line">传进来的a 1 1754898956528</span><br><span class="line">函数内部加一后的a 2 1754898956560</span><br><span class="line">经过函数变化后的a 1 1754898956528</span><br></pre></td></tr></table></figure>

<p>可见如果传参在函数内部变化，就会生成新的变量，占用新的内存？</p>
<hr>
<p><strong>可变参数</strong><br>这类参数传参时<strong>不能指定参数名</strong></p>
<ul>
<li>*args：可变<strong>位置</strong>参数<br>接收到的所有按照位置参数方式传进来的参数，是一个元组类型</li>
<li>**kw：可变<strong>关键字</strong>参数<br>接收到的所有按照关键字参数方式传进来的参数，是一个字典类型</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">demo_func</span>(<span class="params">*more, **moremore</span>):</span><br><span class="line">    <span class="built_in">print</span>(more)</span><br><span class="line">    <span class="built_in">print</span>(moremore)</span><br><span class="line"></span><br><span class="line">demo_func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,a=<span class="string">&#x27;a&#x27;</span>,b=&#123;<span class="string">&#x27;b&#x27;</span>:<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>:<span class="string">&#x27;c&#x27;</span>&#125;)</span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># (1, 2, 3)</span></span><br><span class="line"><span class="comment"># &#123;&#x27;a&#x27;: &#x27;a&#x27;, &#x27;b&#x27;: &#123;&#x27;b&#x27;: &#x27;b&#x27;, &#x27;c&#x27;: &#x27;c&#x27;&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<p>一些定义函数参数时的注意事项：</p>
<ul>
<li><p>必选参数一定要在默认参数的前面</p>
</li>
<li><p>可变位置参数一定要在可变关键字参数的前面</p>
</li>
<li><p>可变位置参数可以（不一定要）放在必选参数前面，但在调用时，必选参数必须通过指定参数名来传参</p>
</li>
<li><p>可变关键字参数一定要放在所有参数的最后面</p>
</li>
<li><p>使用四种参数的示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">demo_func</span>(<span class="params">arg1, arg2=<span class="number">10</span>, *args, **kw</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;arg1:&quot;</span>, arg1)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;arg2:&quot;</span>, arg2)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;args:&quot;</span>, args)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;kw&quot;</span>, kw)</span><br><span class="line"></span><br><span class="line">demo_func(<span class="number">1</span>, <span class="number">12</span>, <span class="number">100</span>, <span class="number">200</span>, a=<span class="number">1000</span>, b=<span class="string">&quot;Archeri&quot;</span>)</span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># arg1: 1</span></span><br><span class="line"><span class="comment"># arg2: 12</span></span><br><span class="line"><span class="comment"># args: (100, 200)</span></span><br><span class="line"><span class="comment"># kw &#123;&#x27;a&#x27;: 1000, &#x27;b&#x27;: &#x27;Archeri&#x27;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用单独的‘*’，当给其后面位置的参数传参时，必须以关键字参数的形式传参，否则报错。例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">demo_func</span>(<span class="params">a, b, *, c, d=<span class="number">10</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="built_in">print</span>(b)</span><br><span class="line">    <span class="built_in">print</span>(c)</span><br><span class="line">    <span class="built_in">print</span>(d)</span><br><span class="line"></span><br><span class="line">demo_func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#   File &quot;D:\python_work\guide\test.py&quot;, line 7, in &lt;module&gt;</span></span><br><span class="line"><span class="comment">#     demo_func(1, 2, 3)</span></span><br><span class="line"><span class="comment"># TypeError: demo_func() takes 2 positional arguments but 3 were given</span></span><br><span class="line">demo_func(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#   File &quot;D:\python_work\guide\review.py&quot;, line 7, in &lt;module&gt;</span></span><br><span class="line"><span class="comment">#     demo_func(1,2)</span></span><br><span class="line"><span class="comment"># TypeError: demo_func() missing 1 required keyword-only argument: &#x27;c&#x27;</span></span><br><span class="line">demo_func(<span class="number">1</span>, <span class="number">2</span>, c=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 10</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-3-匿名函数"><a href="#5-3-匿名函数" class="headerlink" title="5.3 匿名函数"></a>5.3 匿名函数</h3><p>lambda表达式<br>lambda后面跟形参，冒号后面跟返回结果，再后面跟实参</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一般函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_sum</span>(<span class="params">x, y</span>):</span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line"><span class="comment"># 等价的匿名函数</span></span><br><span class="line">(<span class="keyword">lambda</span> x,y:x+y)(<span class="number">2</span>, <span class="number">4</span>)	<span class="comment"># 该表达式返回6</span></span><br><span class="line"><span class="comment"># 一个带分支结构的</span></span><br><span class="line">(<span class="keyword">lambda</span> x,y:x <span class="keyword">if</span> x&lt;y <span class="keyword">else</span> y)(<span class="number">1</span>,<span class="number">2</span>)	<span class="comment"># 该表达式返回1（较小数）</span></span><br></pre></td></tr></table></figure>

<p>值得注意的是lambda是一个<strong>表达式</strong>，而不是语句<br>因此适用在特殊场景</p>
<h3 id="5-4-常用函数（结合匿名函数）"><a href="#5-4-常用函数（结合匿名函数）" class="headerlink" title="5.4 常用函数（结合匿名函数）"></a>5.4 常用函数（结合匿名函数）</h3><p><strong>map()</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一般情况</span></span><br><span class="line">ls = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]:</span><br><span class="line">    ls.append(i*<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 结合lambda</span></span><br><span class="line">ls = <span class="built_in">map</span>(<span class="keyword">lambda</span> x:x*<span class="number">2</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])	<span class="comment"># 返回map对象（迭代器），可用list()转化为列表，仅为python3特性</span></span><br></pre></td></tr></table></figure>

<p><strong>filter()</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x:x%<span class="number">2</span> == <span class="number">1</span>, <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>)))</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<p><strong>reduce()</strong></p>
<blockquote>
<p>它的作用是先对序列中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 lambda函数运算，将其得到的结果再与第四个元素进行运算，以此类推下去直到后面没有元素了。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line">a = reduce(<span class="keyword">lambda</span> x,y:x+y, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>

<h3 id="5-5-反射函数（自省机制？）"><a href="#5-5-反射函数（自省机制？）" class="headerlink" title="5.5 反射函数（自省机制？）"></a>5.5 反射函数（自省机制？）</h3><p><strong>自省机制</strong>，内容包括：</p>
<ol>
<li>告诉别人，我是谁</li>
<li>告诉别人，我能做什么</li>
</ol>
<p>有了这个，就能让程序在运行时能获知对象的类型以及该对象下有哪些方法等</p>
<hr>
<p>下面是一些自行机制中涉及到的常用函数<br>具体用法另看</p>
<ul>
<li>help()：帮助</li>
<li>dir()：返回传递给它的任何对象的属性名称经过排序的列表。如果不指定对象，则返回当前作用域中的名称。</li>
<li>type()：返回对象类型</li>
<li>hasattr()：检查某对象是否有某属性</li>
<li>getattr()：从某对象中获取某属性的值</li>
<li>id()：返回对象的唯一标识符（内存地址）</li>
<li>isinstance()：确定某个对象是否为某个指定类的实例</li>
<li>callable()：确定某个对象是否为可调用的</li>
</ul>
<hr>
<p><strong>模块的魔法属性</strong></p>
<p>都是类似于‘modules.__doc__’之类的形式使用</p>
<ul>
<li>__doc__：返回模块的文档</li>
<li>__name__：返回模块的原名（定义时的模块名）</li>
<li>__file__：返回包含了该模块的文件路径</li>
<li>__dict__：返回模块里可用的‘属性名:属性’字典，也就是可以使用‘模块名.属性名’访问的对象</li>
</ul>
<hr>
<p><strong>类的魔法属性</strong></p>
<p>都是类似于‘class.__doc__’之类的形式使用</p>
<ul>
<li>__doc__：返回类的文档字符串（类定义前面的三引号字符串）</li>
<li>__name__：返回类的原名（定义时的类名）</li>
<li>__dict__：返回类里可用的‘属性名:属性’字典，也就是可以使用‘类名.属性名’访问的对象</li>
<li>__module__：返回包含了该类的模块名</li>
<li>__bases__：返回类继承自的<strong>直接父类</strong>对象的元组</li>
</ul>
<h3 id="5-6-偏函数"><a href="#5-6-偏函数" class="headerlink" title="5.6 偏函数"></a>5.6 偏函数</h3><p>大概就是<br>可以将某个函数的常用参数进行固定<br>指定一个新的函数名<br>避免每次调用时都要指定某个参数</p>
<p>一个例子是<br>假如有这么一个函数<code>power(x,n)</code><br>功能是计算x的n次方<br>那么可以定义一个常用的平方计算函数<br><code>from functools import partial</code><br><code>power_2 = partial(power, n=2)</code><br>这样调用<code>power_2(x)</code><br>就可以使用power()函数计算x的平方了</p>
<p>我的评价是：可能很少用</p>
<h3 id="5-7-泛型函数"><a href="#5-7-泛型函数" class="headerlink" title="5.7 泛型函数"></a>5.7 泛型函数</h3><p>泛型，一般指根据传入参数类型的不同从而调用不同的函数体<br>Python里边叫<strong>singledispatch</strong></p>
<p>只要被singledispatch装饰的函数<br>就是一个single-dispatch的泛函数（generic functions）<br>注意<code>from functools import singledispatch </code></p>
<ul>
<li><strong>单分派</strong>：根据一个参数的类型，以不同方式执行相同的操作的行为</li>
<li><strong>多分派</strong>：可根据多个参数的类型选择专门的函数的行为</li>
<li><strong>泛函数</strong>：多个函数绑在一起组合成一个泛函数</li>
</ul>
<p>简单的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> singledispatch</span><br><span class="line"></span><br><span class="line"><span class="meta">@singledispatch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">age</span>(<span class="params">obj</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;???&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@age.register(<span class="params"><span class="built_in">int</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_</span>(<span class="params">age</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;int:&quot;</span>, <span class="built_in">str</span>(age))</span><br><span class="line"></span><br><span class="line"><span class="meta">@age.register(<span class="params"><span class="built_in">str</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_</span>(<span class="params">age</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;str:&quot;</span>, age)</span><br><span class="line"></span><br><span class="line">age(<span class="number">22</span>)</span><br><span class="line">age(<span class="string">&quot;twenty two&quot;</span>)</span><br><span class="line">age([<span class="number">22</span>])</span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="comment"># int: 22</span></span><br><span class="line"><span class="comment"># str: twenty two</span></span><br><span class="line"><span class="comment"># ???</span></span><br></pre></td></tr></table></figure>

<p>然后举例了一个适用场景</p>
<p>下次想规定函数根据传参的不同来进行不同的行为<br>就不用一直if-elif了</p>
<h3 id="5-8-变量的作用域"><a href="#5-8-变量的作用域" class="headerlink" title="5.8 变量的作用域"></a>5.8 变量的作用域</h3><p><strong>作用域</strong><br>分为四种，同时也是变量&#x2F;函数的查找顺序</p>
<ol>
<li>L（Local）局部作用域</li>
<li>E（Enclosing）闭包函数外的函数中</li>
<li>G（Global）全局作用域</li>
<li>B（Built-in）内建作用域</li>
</ol>
<p>会影响变量&#x2F;函数作用范围的有：</p>
<ul>
<li>函数：def、lambda</li>
<li>类：class</li>
<li>关键字：global、noglobal</li>
<li>文件：*py</li>
<li>推导式：[]、{}、()等（仅Python3.x）</li>
</ul>
<hr>
<p><strong>闭包</strong></p>
<blockquote>
<p>在一个外函数中定义了一个内函数<br>内函数里运用了外函数的临时变量<br>并且外函数的返回值是<strong>内函数的引用</strong><br>这样就构成了一个闭包</p>
<p>其实<strong>装饰函数</strong>，很多都是闭包</p>
</blockquote>
<p>一般函数结束时，函数内部的临时变量等都会被释放掉<br>但闭包是特殊情况<br>如果外函数在结束的时候发现有自己的临时变量将来会在内部函数中用到<br>就把这个临时变量绑定给了内部函数<br>然后自己再结束</p>
<p>例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">deco</span>():</span><br><span class="line">    name = <span class="string">&quot;Archeri&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>():</span><br><span class="line">        <span class="built_in">print</span>(name)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">deco()()	<span class="comment"># 输出“Archeri”</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>改变作用域</strong></p>
<p>变量的作用域，与其定义&#x2F;赋值的位置有关，但不是绝对相关<br>可以在某种程度上去<strong>向上</strong>改变变量的作用范围</p>
<ul>
<li>global：将局部变量提升为全局变量</li>
<li>nonlocal：在闭包函数中引用并使用<strong>外部函数的变量</strong></li>
</ul>
<p>例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">deco</span>():</span><br><span class="line">    age = <span class="number">10</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> age    <span class="comment"># 不加这句会报错</span></span><br><span class="line">        age += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(age)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">deco()()	<span class="comment"># 使age加一</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>变量集合</strong></p>
<ul>
<li>globals()：返回以字典方式存储的所有全局变量&#x2F;函数</li>
<li>locals()：返回以字典方式存储的所有局部变量&#x2F;函数</li>
</ul>
<p>例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I am a func&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">    foo=<span class="string">&quot;I am a string&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">globals</span>())</span><br><span class="line"><span class="comment"># 指出foo是一个函数而不是字符串</span></span><br><span class="line"><span class="comment"># 还有其他的一些全局变量</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ther = <span class="string">&quot;test&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foobar</span>():</span><br><span class="line">    name = <span class="string">&quot;Archeri&quot;</span></span><br><span class="line">    age = <span class="number">22</span></span><br><span class="line">    <span class="keyword">for</span> key,value <span class="keyword">in</span> <span class="built_in">locals</span>().items():</span><br><span class="line">        <span class="built_in">print</span>(key, <span class="string">&quot;=&quot;</span>, value)</span><br><span class="line"></span><br><span class="line">foobar()</span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="comment"># name = Archeri</span></span><br><span class="line"><span class="comment"># age = 22</span></span><br></pre></td></tr></table></figure>

<h3 id="5-9-上下文管理器"><a href="#5-9-上下文管理器" class="headerlink" title="5.9 上下文管理器"></a>5.9 上下文管理器</h3><p>一个很常见的例子是<br>使用open()打开文件之后，使用with关键字，避免手动关闭文件句柄<br>这里with的用法，在Python专业术语上叫上下文管理器</p>
<ol>
<li><p>上下文表达式：<code>with open(&#39;test.txt&#39;) as file:</code></p>
</li>
<li><p>上下文管理器：<code>open(&#39;test.txt&#39;)</code></p>
</li>
<li><p>file不是上下文管理器，而是资源对象</p>
</li>
</ol>
<p>使用上下文管理器<br>可以更加优雅地进行操作资源、处理异常<br>也能提高代码重用率</p>
<p>Python 3.10中新增可以将with语句分开多行写<br>提高代码可读性和优雅程度</p>
<hr>
<p><strong>自定义上下文管理器</strong></p>
<p>只要在一个类里面实现上下文管理器协议<br>就是在类里面定义<strong>__enter()__和__exit()__方法</strong><br>那么这个类的实例就是一个上下文管理器</p>
<p>当进入上下文表达式时，会自动调用类的__enter()__方法（在此打开连接）<br>当离开上下文表达式的范围时，会自动调用类的__exit()__方法（在此关闭连接）</p>
<hr>
<p><strong>处理异常</strong></p>
<p>使用上下文管理器处理异常，可以避免代码中大量try-execept的使用</p>
<p>一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;===connect to resource===&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;===close resource connection===&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operate</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="number">1</span>/<span class="number">0</span></span><br><span class="line"><span class="comment"># 下面语句不会报错</span></span><br><span class="line"><span class="keyword">with</span> Resource() <span class="keyword">as</span> res:</span><br><span class="line">    res.operate()</span><br></pre></td></tr></table></figure>

<p>异常可以在__exit()__进行捕获，并自行决定如何处理<br>返回True即已对异常进行捕获，无需再往外抛出<br>返回False则往外抛出异常<br>无return则默认返回False</p>
<p>写__exit()__处理异常时，必须包含这三个参数（没有报错时都为None）：</p>
<ul>
<li><p>exc_type：异常类型</p>
</li>
<li><p>exc_val：异常值</p>
</li>
<li><p>exc_tb：异常错误栈信息</p>
</li>
</ul>
<hr>
<p><strong>contextlib</strong></p>
<p>一个装饰器<br>通过这个可以让一个函数（生成器）对象变成一个上下文管理器，而不用写一个类</p>
<p>重点在于：</p>
<ul>
<li>函数定义前使用<code>@contextlib.contextmanager</code>修饰<br>（import contextlib）</li>
<li>函数体内部使用<code>yield &#123;资源对象&#125;</code></li>
<li>yield语句之前的代码都相当于__enter()__方法的内容</li>
<li>yield语句之后的代码都相当于__exit()__方法的内容</li>
</ul>
<p>这样一般不能够进行异常处理<br>如果<strong>硬是要</strong>异常处理，可以尝试改成下面的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@contextlib.contextmanager</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">open_func</span>(<span class="params">file_name</span>):</span><br><span class="line">    <span class="comment"># __enter__方法</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;open file:&#x27;</span>, file_name, <span class="string">&#x27;in __enter__&#x27;</span>)</span><br><span class="line">    file_handler = <span class="built_in">open</span>(file_name, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> file_handler</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</span><br><span class="line">        <span class="comment"># deal with exception</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;the exception was thrown&#x27;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;close file:&#x27;</span>, file_name, <span class="string">&#x27;in __exit__&#x27;</span>)</span><br><span class="line">        file_handler.close()</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<h3 id="5-10-装饰器"><a href="#5-10-装饰器" class="headerlink" title="5.10 装饰器"></a>5.10 装饰器</h3><p>另有笔记，建议看<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43266093/article/details/121685826">这里</a></p>
<p><strong>概述</strong></p>
<p>本质上是Python函数<br>可以让其他函数原封不动地增加额外功能<br>装饰器的返回值也是一个函数对象</p>
<p>有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续使用</p>
<p>用法三部曲：</p>
<ol>
<li>定义装饰器</li>
<li>定义函数&#x2F;类</li>
<li>装饰器装饰函数&#x2F;类</li>
</ol>
<p>例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义装饰器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kw</span>):</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义业务函数并进行装饰</span></span><br><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">function</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello, decorator&quot;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>普通装饰器</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 装饰器函数，参数func是被装饰的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">logger</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kw</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;===执行 &#123;&#125; 函数===&quot;</span>.<span class="built_in">format</span>(func.__name__))</span><br><span class="line">        <span class="comment"># 真正执行函数的地方</span></span><br><span class="line">        func(*args, **kw)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;===执行完毕===&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"><span class="comment"># 业务函数，被logger装饰器装饰</span></span><br><span class="line"><span class="meta">@logger</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="built_in">print</span>(x + y)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="comment"># output</span></span><br><span class="line">    <span class="comment"># ===执行 add 函数===</span></span><br><span class="line">    <span class="comment"># 3</span></span><br><span class="line">    <span class="comment"># ===执行完毕===</span></span><br></pre></td></tr></table></figure>

<p>所以要理解装饰器，可以从它名字本身进行入手<br>“装饰”，意味对对象进行包装，但不改变其本质上的内容<br>如上例，只是在被装饰的函数执行前后输出一些日志<br>确有“装饰”的意思</p>
<hr>
<p><strong>带参数的函数装饰器</strong></p>
<p>上面那种不传参的装饰器<br>只能对被装饰的函数执行额外的<strong>固定</strong>逻辑</p>
<p>若想装饰器本身能够根据参数执行不同逻辑<br>则要像下面的例子一样写装饰器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">greet_age</span>(<span class="params">age</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">deco</span>(<span class="params">*args, **kw</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;i&#x27;m &#123;&#125; years old&quot;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(age)))</span><br><span class="line">            <span class="comment"># 真正执行函数的地方</span></span><br><span class="line">            func(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> deco</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@greet_age(<span class="params"><span class="number">22</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">archeri</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i&#x27;m Archeri&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@greet_age(<span class="params"><span class="number">21</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">librarian</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i&#x27;m librarian&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    archeri()</span><br><span class="line">    librarian()</span><br><span class="line">    <span class="comment"># output</span></span><br><span class="line">    <span class="comment"># i&#x27;m 22 years old</span></span><br><span class="line">    <span class="comment"># i&#x27;m Archeri</span></span><br><span class="line">    <span class="comment"># i&#x27;m 21 years old</span></span><br><span class="line">    <span class="comment"># i&#x27;m librarian</span></span><br></pre></td></tr></table></figure>

<p>不太会，还得再看看</p>
<hr>
<p><strong>不带参数的类装饰器</strong></p>
<p>装饰器还可以用类来实现<br>这种类中必须实现**__call()__<strong>和</strong>__init()__**两个内置方法</p>
<ul>
<li>__init()__：接收被装饰的函数</li>
<li>__call()__：实现装饰逻辑</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">logger</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        <span class="variable language_">self</span>.func = func</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[INFO]: the function &#123;&#125;() is running...&quot;</span>\</span><br><span class="line">              .<span class="built_in">format</span>(<span class="variable language_">self</span>.func.__name__))</span><br><span class="line">        <span class="comment"># 真正执行函数的在这里</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="meta">@logger</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">something</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;say &#123;&#125;!&quot;</span>.<span class="built_in">format</span>(something))</span><br><span class="line"></span><br><span class="line">say(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="comment"># [INFO]: the function say() is running...</span></span><br><span class="line"><span class="comment"># say hello!</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>带参数的类装饰器</strong></p>
<p>可以给类装饰器闯入参数，使类装饰器能够执行不同的逻辑<br>带参数和不带参数的类装饰器有很大的不同</p>
<ul>
<li>__init()__：不再接收被装饰函数，而是<strong>接收传入参数</strong></li>
<li>__call()__：<strong>接收被装饰函数</strong>，实现装饰逻辑</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">logger</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 接收参数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, level=<span class="string">&#x27;INFO&#x27;</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.level = level</span><br><span class="line">    <span class="comment"># 接收函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[&#123;&#125;]: the function &#123;&#125;() is running...&quot;</span>\</span><br><span class="line">                .<span class="built_in">format</span>(<span class="variable language_">self</span>.level, func.__name__))</span><br><span class="line">            <span class="comment"># 真正执行函数的地方</span></span><br><span class="line">            func(*args, **kwargs)</span><br><span class="line">        <span class="comment"># 返回函数</span></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@logger(<span class="params">level=<span class="string">&#x27;WARNING&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">something</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;say &#123;&#125;!&quot;</span>.<span class="built_in">format</span>(something))</span><br><span class="line"></span><br><span class="line">say(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="comment"># [WARNING]: the function say() is running...</span></span><br><span class="line"><span class="comment"># say hello!</span></span><br></pre></td></tr></table></figure>

<hr>
<p>还有<strong>使用偏函数与类实现装饰器</strong>以及<strong>能装饰类的装饰器</strong></p>
<p><del>这都什么勾⑧玩意儿啊</del><br><del>太nm难了，先搞懂前面讲的那几种再来看看剩下的</del><br><del>建议另找教程学</del><br><del>暂定目标：能做到简化日志记录代码即可</del></p>
<p>已经对装饰器基础、普通装饰器和类装饰器的写法都有了一定的理解<br>另有笔记</p>
<h2 id="第六章-错误异常"><a href="#第六章-错误异常" class="headerlink" title="第六章 错误异常"></a>第六章 错误异常</h2><h3 id="6-1-常见异常"><a href="#6-1-常见异常" class="headerlink" title="6.1 常见异常"></a>6.1 常见异常</h3><ul>
<li><code>SyntaxError</code>：语法错误</li>
<li><code>TypeError</code>：类型错误</li>
<li><code>IndexError</code>：索引错误，如下标越界等</li>
<li><code>KeyError</code>：关键字错误，如访问字典中不存在的键等</li>
<li><code>ValueError</code>：值错误，如传入一个不符合调用者的值等</li>
<li><code>AttributeError</code>：属性错误，如访问对象一个不存在的属性等</li>
<li><code>NameError</code>：变量名错误，如调用一个未赋值或初始化的变量等</li>
<li><code>IOError</code>：文件读写错误，如打开不存在的文件等</li>
<li><code>StopIteration</code>：迭代器错误，如访问到迭代器最后值还继续访问等</li>
<li><code>AssertionError</code>：断言错误，如<code>assert</code>语句检测的表达式为假等</li>
<li><code>IndentationError</code>：缩进错误</li>
<li><code>ImportError</code>：导入包错误</li>
</ul>
<p>更多Python内置异常见<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/exceptions.html">官方文档</a></p>
<h3 id="6-2-抛出和捕获异常"><a href="#6-2-抛出和捕获异常" class="headerlink" title="6.2 抛出和捕获异常"></a>6.2 抛出和捕获异常</h3><p><strong>抛出异常</strong></p>
<p>两种方式产生异常：</p>
<ul>
<li>程序自动抛出</li>
<li>开发者使用<code>raise</code>主动抛出</li>
</ul>
<hr>
<p><strong>捕获异常</strong></p>
<p>基础语法：<br>常将异常信息赋值给一个‘e’，方便进行打印和操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	<span class="comment"># 代码A</span></span><br><span class="line"><span class="keyword">except</span> [EXCEPTION] <span class="keyword">as</span> e:</span><br><span class="line">	<span class="comment"># 代码B</span></span><br></pre></td></tr></table></figure>

<p>例如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>+<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> TypeError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure>

<p>输出：<em>unsupported operand type(s) for +: ‘int’ and ‘str’</em></p>
<p>拓展语法：<code>try-except-else-finally</code><br>其中<code>else</code>和<code>finally</code>部分可分别单独存在</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 尝试运行的代码</span></span><br><span class="line"><span class="keyword">except</span> [EXCEPTION] <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 若发生异常则执行这里的代码</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 若没有发生异常则执行这里的代码</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># 不管有没有发生异常，最后都会执行这里的代码</span></span><br></pre></td></tr></table></figure>

<p><strong>捕获多个异常</strong></p>
<p>一般是这样子，执行第一个捕获到的异常处理代码，抛弃剩下的异常捕获代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 尝试运行的代码</span></span><br><span class="line"><span class="keyword">except</span> [EXCEPTION1] <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 发生EXCEPTION1</span></span><br><span class="line"><span class="keyword">except</span> [EXCEPTION2] <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 发生EXCEPTION2</span></span><br><span class="line"><span class="keyword">except</span> [EXCEPTION3] <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 发生EXCEPTION3</span></span><br></pre></td></tr></table></figure>

<p>有些时候多种异常的处理代码都是一样的，则可以这样子写多异常捕获：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	<span class="comment"># 一些计算</span></span><br><span class="line"><span class="keyword">except</span> IOError:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;IO读写出错&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> (ZeroDivisionError, FloatingPointError):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;计算错误&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这样子不管是出现了除0错误还是浮点数异常，都会统一处理输出“计算错误”</p>
<h3 id="6-3-自定义异常"><a href="#6-3-自定义异常" class="headerlink" title="6.3 自定义异常"></a>6.3 自定义异常</h3><p>异常可以自定义，应该直接或间接继承<code>Exception</code></p>
<p>命名上，最好都应该以“Error”结尾</p>
<p>都应该实现<code>__str__</code>魔术方法，以便输出显示错误详情的信息</p>
<p>例如下面一个自定义的异常：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyError</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, msg</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.msg = msg</span><br><span class="line">        <span class="variable language_">self</span>.num = <span class="number">13</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.msg&#125;</span> &lt;&gt; <span class="subst">&#123;self.num&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>测试抛出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;Archeri&quot;</span></span><br><span class="line"><span class="keyword">if</span> name != <span class="string">&quot;Cacy&quot;</span>:</span><br><span class="line">    <span class="keyword">raise</span> MyError(<span class="string">&quot;You are not Archeri!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;D:<span class="keyword">\python</span><span class="built_in">_</span>work<span class="keyword">\guide</span><span class="keyword">\test</span>.py&quot;, line 12, in &lt;module&gt;</span><br><span class="line">    raise MyError(&quot;You are not Archeri!&quot;)</span><br><span class="line"><span class="built_in">_</span><span class="built_in">_</span>main<span class="built_in">_</span><span class="built_in">_</span>.MyError: You are not Archeri! &lt;&gt; 13</span><br></pre></td></tr></table></figure>

<h3 id="6-4-关闭异常自动关联上下文"><a href="#6-4-关闭异常自动关联上下文" class="headerlink" title="6.4 关闭异常自动关联上下文"></a>6.4 关闭异常自动关联上下文</h3><p>有时候抛出一个异常时，可能会携带原始的异常信息<br>若想关闭异常自动关联上下文，则可以在抛出时使用<code>raise [Excp] from None</code></p>
<p>如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="number">1</span>/<span class="number">0</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">	<span class="keyword">raise</span> RuntimeError(<span class="string">&quot;Something bad happened&quot;</span>) <span class="keyword">from</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>这样就仅会抛出<code>RuntimeError</code>而不会顺便抛出<code>ZeroDivisionErrpr</code></p>
<h3 id="6-5-异常处理的三个好习惯"><a href="#6-5-异常处理的三个好习惯" class="headerlink" title="6.5 异常处理的三个好习惯"></a>6.5 异常处理的三个好习惯</h3><p><strong>1. 只做最精准的异常捕获（catch）</strong></p>
<p>包括：</p>
<ul>
<li>只catch可能抛出异常的语句块<br>不要连个1+1都<code>try-catch</code></li>
<li>只捕获精准的异常类型<br>而不是笼统的<code>Exception</code><br>或者应该把异常详情完整输出</li>
</ul>
<p><strong>2. 不让异常破坏抽象的一致性</strong></p>
<p>比较涉及到开发，简单提下：</p>
<ul>
<li><p>让模块只抛出与当前抽象层级一致的异常</p>
</li>
<li><p>在必要的地方进行异常包装与转换</p>
</li>
</ul>
<p><strong>3. 异常处理不应该喧宾夺主</strong></p>
<p>核心代码逻辑应该干净有条理，不应该充斥大量的<code>try-catch</code>、<code>except-raise</code></p>
<p>具体实现起来，可以设计一些<strong>上下文管理器</strong>，[上面](#5.9 上下文管理器)简单提及<br>然后使用<code>with</code>语句同时进行逻辑实现以及异常处理</p>
<p><code>contextlib</code>模块提供了很多编写上下文管理器的相关工具函数与样例<br>官方文档在<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/contextlib.html">这里</a></p>
<p>《Guide》里边这一节附有一个例子</p>
<h2 id="第七章-类与对象"><a href="#第七章-类与对象" class="headerlink" title="第七章 类与对象"></a>第七章 类与对象</h2><h3 id="7-1-类的理解与使用"><a href="#7-1-类的理解与使用" class="headerlink" title="7.1 类的理解与使用"></a>7.1 类的理解与使用</h3><p><del>类，累，泪</del></p>
<p>一些概念简单提下<br>类是抽象<br>对象就是类的实例<br>属性就是类中的变量<br>方法就是类中的函数</p>
<p>下面的类定义是等价的：<br><code>class Animal</code>&#x3D;<code>class Animal()</code>&#x3D;<code>class Animal(object)</code><br>因为没有指定继承的情况下，所有类默认继承<code>object</code>类</p>
<p>另外有一种奇奇怪怪的调用方法：<code>类.方法</code><br>由于类是抽象的，所以调用一些方法时可能要传入一个类的实例，例如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dog = Animal(name=<span class="string">&quot;奎恩&quot;</span>)	<span class="comment"># 实例</span></span><br><span class="line">Animal.run(dog)			 <span class="comment"># run是一个实例方法，所以要传入实例参数</span></span><br><span class="line"><span class="comment"># output: 奎恩，跑了起来</span></span><br></pre></td></tr></table></figure>

<h3 id="7-2-实例方法、静态方法与类方法"><a href="#7-2-实例方法、静态方法与类方法" class="headerlink" title="7.2 实例方法、静态方法与类方法"></a>7.2 实例方法、静态方法与类方法</h3><p>类的方法分为：</p>
<ul>
<li>实例方法：没有任何装饰器的普通函数</li>
<li>静态方法：有<code>staticmethod</code>装饰的函数</li>
<li>类方法：有<code>classmethod</code>装饰的函数</li>
</ul>
<p>例如有下面的类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span>，跑了起来&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在吃饭....&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">jump</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;跳起来了&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>实例方法在定义时第一个参数固定是<code>self</code><br>如果从实例调用，则<code>self</code>参数不需要传入<br>如果通过类调用，那么<code>self</code>要传入已经实例化的对象<br>（即一定要有个实例或者已经实例化的对象，才能调用）</p>
<p>静态方法在定义时不需要<code>self</code>参数<br>就算定义时给出了<code>self</code>参数，函数内部也捕获不到<code>self</code>的各个属性<br>如<code>self.name</code>是找不到的，会显示<code>TypeError</code><br>可以随便从实例或类调用</p>
<p>类方法在定义时第一个参数固定是<code>cls</code>，代表类本身<br>不管是从实例还是类调用，都不需要传入<code>cls</code>参数</p>
<p>普通函数和静态方法都是<strong>函数（function）</strong><br>实例方法和类方法都是<strong>方法（method）</strong><br>上述可通过<code>type</code>函数确认</p>
<h3 id="7-3-私有变量和私有方法"><a href="#7-3-私有变量和私有方法" class="headerlink" title="7.3 私有变量和私有方法"></a>7.3 私有变量和私有方法</h3><p>在Python里面，可以用下划线<code>_</code>设置变量和方法的访问控制<br>具体指前导单下划线<code>_var</code>和前导双下划线<code>__var</code></p>
<p><strong>前导单下划线</strong></p>
<p>例如有下面这个类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.var1 = <span class="number">1</span></span><br><span class="line">        <span class="variable language_">self</span>._var2 = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>实例化<code>demo = Demo()</code><br>之后会发现，外界都可以直接访问这两个属性</p>
<p>也就是说，这种访问控制<strong>不是强制性的</strong><br>更像是一种编码规范，开发者们最好遵守这一共识</p>
<p><strong>前导双下划线</strong></p>
<p>如果上面的<code>Demo</code>类新增一个属性<code>self.__var3 = 3</code><br>然后实例化再去通过实例访问，则会报<code>AttributeError</code>异常，提示属性不存在</p>
<p>通过<code>dir(demo)</code>查看对象的属性，会发现有一个<code>_Demo__var3</code>而没有<code>__var3</code><br>这实际上是Python解释器所做的<strong>名称修饰</strong><br>是为了防止变量在子类中被重写</p>
<p>若想访问的话，则得按照<code>dir</code>函数提示的写法去访问，在<code>__var3</code>前面加上<code>_类名</code><br>变成<code>_Demo__var3</code></p>
<p>所以前导双下划线的属性变量，是一个<strong>实实在在的私有变量</strong></p>
<p>上述规则在方法上同样适用<br>例如必须是<code>实例._类名__方法名</code></p>
<hr>
<p><strong>总结</strong></p>
<blockquote>
<p>Python并没有真正的私有化支持，但可用下划线得到<strong>伪私有</strong>。</p>
</blockquote>
<p>私有变量和私有方法虽然有方法从外部直接访问，但是不建议这样做<br>而应该设置统一的接口（函数入口）来对私有变量&#x2F;方法进行查看&#x2F;调用<br>详细见下面“类的封装”的内容</p>
<h3 id="7-4-类的封装"><a href="#7-4-类的封装" class="headerlink" title="7.4 类的封装"></a>7.4 类的封装</h3><p>严谨点，来段定义</p>
<blockquote>
<p>封装是指将数据与具体操作的实现代码放在某个对象内部，使这些代码的实现细节不被外界发现，外界只能通过接口使用该对象，而不能通过任何形式修改对象内部实现。</p>
</blockquote>
<p>一个很简单的封装例子：女人的年龄是秘密</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">		<span class="variable language_">self</span>.name = name</span><br><span class="line">		<span class="variable language_">self</span>.__age = age</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">is_adult</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> <span class="variable language_">self</span>.__age &gt;= <span class="number">18</span></span><br><span class="line"></span><br><span class="line">xh = Person(name=<span class="string">&quot;小红&quot;</span>, age=<span class="number">27</span>)</span><br><span class="line">xh.is_adult()</span><br></pre></td></tr></table></figure>

<p>外部无法随意访问<code>__age</code>属性，即无法直接获取年龄<br>只能通过接口进行特定访问</p>
<h3 id="7-5-类的继承"><a href="#7-5-类的继承" class="headerlink" title="7.5 类的继承"></a>7.5 类的继承</h3><p>继承的基本结构：<code>class 子类(父类):</code></p>
<p>单继承的话比较简单，提到了覆写方法啥的</p>
<p>多继承就比较复杂</p>
<p>下面涉及到一个继承顺序的问题<br>当继承的多个父类有同一个方法<br>则子类调用该方法时，按照以下顺序进行查找是调用哪一个方法：</p>
<ul>
<li>从左向右</li>
<li>深度优先</li>
</ul>
<p>例子：</p>
<p><img src="/2022/09/28/%E3%80%8APython-Guide%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220110205640633.png" alt="image-20220110205640633"></p>
<h3 id="7-7-类的property属性"><a href="#7-7-类的property属性" class="headerlink" title="7.7 类的property属性"></a>7.7 类的property属性</h3><p>Python中一个内置的装饰器，它可以在新式类中把一个函数“改造”成属性<br>同时这个属性拥有一些函数的特性，可以<strong>进行一定的逻辑处理</strong></p>
<p>典型的例子是，people类的<code>age</code>属性不能为负数，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">age</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># print(&quot;hehe&quot;) 在这里执行其他代码没有用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._age</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @age.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">age</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt;= value &lt;= <span class="number">150</span>:</span><br><span class="line">            <span class="variable language_">self</span>._age = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;???&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @age.getter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">age</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;try&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._age</span><br></pre></td></tr></table></figure>

<p>先把属性定义成函数的形式，用<code>property</code>装饰<br>返回该属性加一个前导下划线的新变量</p>
<p>后面就可以定义关于该变量的一些特定逻辑行为：</p>
<ul>
<li><code>变量.setter</code>装饰：赋值该变量时执行</li>
<li><code>变量.getter</code>装饰：读取该变量时执行</li>
</ul>
<h3 id="7-8-Mixin设计模式"><a href="#7-8-Mixin设计模式" class="headerlink" title="7.8 Mixin设计模式"></a>7.8 Mixin设计模式</h3><p>更偏向于编码规范，暂时不是我的学习需求</p>
<p>先略</p>
<h3 id="7-9-魔术方法"><a href="#7-9-魔术方法" class="headerlink" title="7.9 魔术方法"></a>7.9 魔术方法</h3><p><a href="www.rafekettler.com/magicmethods.html">这里</a>是外国大神整理的类的魔术方法列表，可能会由于“伟大的墙”的原因无法访问<br><a target="_blank" rel="noopener" href="https://pyzh.readthedocs.io/en/latest/python-magic-methods-guide.html">这里</a>是国内大神翻译上面的</p>
<p>（为什么我在Python官方文档里找不到相关的汇总？）</p>
<p>由于有很多很多，这里就简单记一些熟悉和应该常用的吧</p>
<h4 id="01-构造方法"><a href="#01-构造方法" class="headerlink" title="01. 构造方法"></a>01. 构造方法</h4><ul>
<li><code>__new__(cls, [...])</code><br>对象实例化时第一个调用的方法<br>它只取下<code>cls</code>参数，并把其他参数传给<code>__init__</code><br>（知道是实例化第一个调用的方法就行，不常用）</li>
<li><code>__init__(self, [...])</code><br>类的初始化方法<br>它获取任何传给构造器的参数</li>
<li><code>__del__(self)</code><br>定义对象被垃圾回收时的一些行为<br><strong>非实现<code>del &#123;XXX对象&#125;</code>语句（即不等同于<code>x.__del__()</code>）</strong></li>
</ul>
<p>一个涉及文件操作句柄正确处理的例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileObject</span>:</span><br><span class="line">	<span class="string">&#x27;&#x27;&#x27;文件对象的装饰类，确保文件被删除时的正确关闭&#x27;&#x27;&#x27;</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, filepath=<span class="string">&#x27;~&#x27;</span>, filename=<span class="string">&#x27;sample.txt&#x27;</span></span>):</span><br><span class="line">		<span class="variable language_">self</span>.file = <span class="built_in">open</span>(join(filepath, filename), <span class="string">&#x27;r+&#x27;</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="variable language_">self</span>.file.close()	<span class="comment"># 关闭文件句柄</span></span><br><span class="line">		<span class="keyword">del</span> <span class="variable language_">self</span>.file		<span class="comment"># 回收文件对象</span></span><br></pre></td></tr></table></figure>

<h4 id="02-比较操作符"><a href="#02-比较操作符" class="headerlink" title="02. 比较操作符"></a>02. 比较操作符</h4><ul>
<li><code>__cmp__(self, other)</code><br>实际上定义了所有比较操作符的行为（&lt;、&#x3D;&#x3D;、!&#x3D;等等）<br>理应在self &lt; other 时返回一个负整数<br>在 self &#x3D;&#x3D; other 时返回0<br>在 self &gt; other 时返回正整数<br>（感觉少用？）</li>
<li><code>__eq__(self, other)</code><br>定义操作符<code>==</code>的行为</li>
<li><code>__ne__(self, other)</code><br>定义操作符<code>!=</code>的行为</li>
<li><code>__lt__(self, other)</code><br>定义操作符<code>&lt;</code>的行为</li>
<li><code>__gt__(self, other)</code><br>定义操作符<code>&gt;</code>的行为</li>
<li><code>__le__(self, other)</code><br>定义操作符<code>≤</code>的行为</li>
<li><code>__ge__(self, other)</code><br>定义操作符<code>≥</code>的行为</li>
</ul>
<h4 id="03-数值操作符"><a href="#03-数值操作符" class="headerlink" title="03. 数值操作符"></a>03. 数值操作符</h4><ul>
<li><p><code>__pos__(self)</code><br>实现取正操作<code>+object</code></p>
</li>
<li><p><code>__neg__(self)</code><br>实现取负操作<code>-object</code></p>
</li>
</ul>
<h4 id="04-算数操作符"><a href="#04-算数操作符" class="headerlink" title="04. 算数操作符"></a>04. 算数操作符</h4><ul>
<li><code>__add__(self, other)</code><br>实现加法<code>+</code>操作</li>
<li><code>__sub__(self, other)</code><br>实现减法<code>-</code>操作</li>
<li><code>__mul__(self, other)</code><br>实现乘法<code>*</code>操作</li>
<li><code>__div__(self, other)</code><br>实现除法<code>/</code>操作</li>
<li><code>__mod__(self, other)</code><br>实现取余<code>%</code>操作</li>
<li><code>__and__(self, other)</code><br>实现按位与<code>&amp;</code>操作</li>
<li><code>__or__(self, other)</code><br>实现按位或<code>|</code>操作</li>
<li><code>__xor__(self, other)</code><br>实现按位异或<code>^</code>操作</li>
<li>还有一些反射运算操作的定义<br>大概是定义<code>A+B</code>和<code>B+A</code>的区别</li>
<li>增强赋值运算符的定义，就是<code>+=</code>、<code>-=</code>等<br>上面的方法名前加<code>i</code><br>例如<code>__iadd__(self, other)</code>、<code>__isub__(self, other)</code></li>
</ul>
<h4 id="05-类型转换操作符"><a href="#05-类型转换操作符" class="headerlink" title="05. 类型转换操作符"></a>05. 类型转换操作符</h4><ul>
<li><code>__int__(self)</code><br>实现到<code>int</code>类型的转换（<code>int()</code>）</li>
<li><code>__float__(self)</code><br>实现到<code>float</code>类型的转换（<code>float()</code>）</li>
<li><code>__str__(self)</code><br>实现调用<code>str()</code>时的行为</li>
<li><code>__repr__(self)</code><br>类似于将一个实例从命令行单独输入时的回显</li>
</ul>
<h4 id="06-访问控制"><a href="#06-访问控制" class="headerlink" title="06. 访问控制"></a>06. 访问控制</h4><ul>
<li><code>__getattr__(self, name)</code><br>定义访问不存在的属性时的行为<br>一般用于灵活处理<code>AttributeError</code></li>
</ul>
<h4 id="07-自定义序列"><a href="#07-自定义序列" class="headerlink" title="07. 自定义序列"></a>07. 自定义序列</h4><p>实现一个不可变容器，需要定义 <code>__len__</code> 和 <code>__getitem__</code><br>可变容器除了上面提到的两个方法之外，还需要定义 <code>__setitem__</code> 和 <code>__delitem__</code><br>如果想可以迭代，需要定义 <code>__iter__</code> ，这个方法返回一个迭代器，迭代器必须遵守迭代器协议，需要定义 <code>__iter__</code> （返回它自己）和 <code>next</code> 方法</p>
<ul>
<li><code>__len__(self)</code><br>返回容器长度</li>
<li><code>__getitem__(self, key)</code><br>定义使用<code>self[key]</code>方法进行读取时的行为<br>应该实现键类型错误时抛出<code>TypeError</code><br>应该实现没有与键值匹配内容时抛出<code>KeyError</code></li>
<li><code>__setietm__(self, key)</code><br>定义使用<code>self[key]</code>方法进行赋值时的行为<br>应该实现键类型错误时抛出<code>TypeError</code><br>应该实现没有与键值匹配内容时抛出<code>KeyError</code></li>
<li><code>__iter__(self, key)</code><br>返回当前容器的迭代器（通常是<code>iter</code>函数调用）</li>
</ul>
<h4 id="08-可调用对象"><a href="#08-可调用对象" class="headerlink" title="08. 可调用对象"></a>08. 可调用对象</h4><p><code>x()</code>等同于<code>x.__call__()</code></p>
<ul>
<li><code>__call__(self, [args...])</code><br>定义实例被调用时的行为</li>
</ul>
<h4 id="09-上下文管理器"><a href="#09-上下文管理器" class="headerlink" title="09. 上下文管理器"></a>09. 上下文管理器</h4><p>[这里](#5.9 上下文管理器)</p>
<h4 id="10-描述符对象"><a href="#10-描述符对象" class="headerlink" title="10. 描述符对象"></a>10. 描述符对象</h4><p>？</p>
<blockquote>
<p>描述符是一个类，当使用取值，赋值和删除时它可以改变其他对象。<br>描述符不是用来单独使用的，它们需要被一个拥有者类所<strong>包含</strong>。</p>
<p>要想成为一个描述符，一个类必须具有实现<code>__get__</code>、<code>__set__</code>和<code>__delete__</code>三个方法中至少一个。</p>
</blockquote>
<ul>
<li><code>__get__(self, instance, owner)</code><br>定义当试图取出描述符的值时的行为<br><code>instance</code>是拥有者类的实例<br><code>owner</code>是拥有者类本身</li>
<li><code>__set__(self, instance, value)</code><br>定义当描述符的值改变时的行为<br><code>instance</code>是拥有者类的实例<br><code>value</code>是要赋给描述符的值</li>
<li><code>__del__(self, instance)</code><br>定义当描述符的值被删除时的行为<br><code>instance</code>是拥有者类的实例</li>
</ul>
<h3 id="7-10-描述符"><a href="#7-10-描述符" class="headerlink" title="7.10 描述符"></a>7.10 描述符</h3><p>[上面](#7.7 类的property属性)提到了<code>property</code>，用于将<strong>函数</strong>改造成<strong>属性</strong>，从而实现“属性”的访问检查</p>
<p>而<code>property</code>的内部原理实际上就是描述符（Descriptor）</p>
<p>描述符的一大作用：<br>能实现“保护属性不受修改”、“属性类型检查”的基本功能，而提高代码复用率</p>
<hr>
<p>假如有这么一个学生类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, math, chinese, english</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.math = math</span><br><span class="line">        <span class="variable language_">self</span>.chinese = chinese</span><br><span class="line">        <span class="variable language_">self</span>.english = english</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">math</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._math</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @math.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">math</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt;= value &lt;= <span class="number">100</span>:</span><br><span class="line">            <span class="variable language_">self</span>._math = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;Valid value must be in [0, 100]&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">chinese</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._chinese</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @chinese.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">chinese</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt;= value &lt;= <span class="number">100</span>:</span><br><span class="line">            <span class="variable language_">self</span>._chinese = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;Valid value must be in [0, 100]&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">english</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._english</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @english.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">english</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt;= value &lt;= <span class="number">100</span>:</span><br><span class="line">            <span class="variable language_">self</span>._english = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;Valid value must be in [0, 100]&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>虽然实现了对于三门成绩的赋值检查，也使用了<code>property</code>装饰器，好像显得很屌<br>但是代码重复还是太厉害了</p>
<p>对于三门成绩，其实它们的需求是一样的<br>因此可以用一个统一的<strong>描述符</strong>来完成</p>
<p>这个描述符是一个类，由<code>Student</code>类包含</p>
<hr>
<p>当一个类实现了以下三个魔术方法中的其中一个，这个类就成了描述符：</p>
<ul>
<li><code>__get__(self, instance, owner)</code><br>定义当试图取出描述符的值时的行为<br><code>instance</code>是拥有者类的实例<br><code>owner</code>是拥有者类本身<br>返回属性的值</li>
<li><code>__set__(self, instance, value)</code><br>定义当描述符的值改变时的行为<br><code>instance</code>是拥有者类的实例<br><code>value</code>是要赋给描述符的值<br>不返回任何内容</li>
<li><code>__del__(self, instance)</code><br>定义当描述符的值被删除时的行为<br><code>instance</code>是拥有者类的实例<br>不返回任何内容</li>
</ul>
<hr>
<p>因此可以这样写一个<code>Score</code>描述符，来描述“成绩”：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Score</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, default=<span class="number">0</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>._score = default</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, instance, value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&quot;Score must be integer&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= value &lt;= <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;Valid value must be in [0, 100]&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="variable language_">self</span>._score = value</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._score</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__delete__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">del</span> <span class="variable language_">self</span>._score</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    math = Score(<span class="number">0</span>)</span><br><span class="line">    chinese = Score(<span class="number">0</span>)</span><br><span class="line">    english = Score(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, math, chinese, english</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.math = math</span><br><span class="line">        <span class="variable language_">self</span>.chinese = chinese</span><br><span class="line">        <span class="variable language_">self</span>.english = english</span><br></pre></td></tr></table></figure>

<p>这样就把“成绩”所需要的控制功能，抽象成了一个描述符<br>用于描述不同科目的分数</p>
<hr>
<p>除了<code>property</code>之外、<code>staticmethod</code>以及<code>classmethod</code><br>都是基于描述符实现的装饰器</p>
<hr>
<p>然而上面的关于描述符的<code>Score</code>例子都是有点问题的<br>因为这时候的每个<code>Score</code>都是类变量，会导致每个实例之间共享同一个类变量值<br>更像是把描述符当做了存储节点</p>
<p>若要把每种成绩变成实例间相互隔离的属性，应该这样写</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Score</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, subject</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = subject</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, instance, value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&quot;Score must be integer&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= value &lt;= <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;Valid value must be in [0, 100]&quot;</span>)</span><br><span class="line">        <span class="comment"># 如此改进，变成实例字典中的一个项</span></span><br><span class="line">        instance.__dict__[<span class="variable language_">self</span>.name] = value</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>):</span><br><span class="line">        <span class="keyword">return</span> instance.__dict__[<span class="variable language_">self</span>.name]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__delete__</span>(<span class="params">self, instance</span>):</span><br><span class="line">        <span class="keyword">del</span> instance.__dict__[<span class="variable language_">self</span>.name]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    math = Score(<span class="string">&#x27;math&#x27;</span>)</span><br><span class="line">    chinese = Score(<span class="string">&#x27;chinese&#x27;</span>)</span><br><span class="line">    english = Score(<span class="string">&#x27;english&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, math, chinese, english</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.math = math</span><br><span class="line">        <span class="variable language_">self</span>.chinese = chinese</span><br><span class="line">        <span class="variable language_">self</span>.english = english</span><br></pre></td></tr></table></figure>

<p>这样则是把描述符直接当作代理，而本身不存储值</p>
<h2 id="第八章-包与模块"><a href="#第八章-包与模块" class="headerlink" title="第八章 包与模块"></a>第八章 包与模块</h2><h3 id="8-1-包、模块和库"><a href="#8-1-包、模块和库" class="headerlink" title="8.1 包、模块和库"></a>8.1 包、模块和库</h3><p><code>.py</code>文件即为<strong>模块</strong>，通过<code>import</code>语句导入，导入时所有的语句都会被执行<br>包里面的变量、函数可以通过<code>模块名.变量/函数名</code>访问</p>
<p>包的<code>__name__</code>变量：</p>
<ul>
<li>当模块被直接执行时，其值为<code>__main__</code></li>
<li>当模块被导入时，其值为实际模块名</li>
</ul>
<p><code>__pycache__</code>与<code>.pyc</code>文件：导入模块时的缓存，下次如果调用的模块未发生变化则跳过编译这一步</p>
<p>传统<strong>包</strong>：一个文件夹下有一个<code>__init__.py</code>文件<br><strong>命名空间包</strong>：只要是文件夹就可以作为包</p>
<p><strong>库</strong>通常认为是完整的项目打包</p>
<p>库＞包＞模块</p>
<ul>
<li>库：可能由多个包和模块组成</li>
<li>包：可能由多个模块组成</li>
<li>模块：一堆函数、类、变量的集合</li>
</ul>
<h3 id="8-2-包的安装"><a href="#8-2-包的安装" class="headerlink" title="8.2 包的安装"></a>8.2 包的安装</h3><p><code>setup.py</code>文件：运行<code>python setup.py install</code></p>
<h3 id="8-4-导入包的标准写法"><a href="#8-4-导入包的标准写法" class="headerlink" title="8.4 导入包的标准写法"></a>8.4 导入包的标准写法</h3><p>虽然可以使用相对路径<code>..</code>来导入包，但不建议使用</p>
<p>规范导包：</p>
<ul>
<li><code>import</code>语句分行写</li>
<li>使用绝对路径导入</li>
<li><code>import</code>语句放在文件头部，模块说明与<code>docstring</code>之后，全局变量之前</li>
<li>先导入内置模块，再导入第三方模块，最后导入自己的模块，每组之间用单行相隔、字母排序</li>
</ul>
<h3 id="8-5-常规包与命名空间包"><a href="#8-5-常规包与命名空间包" class="headerlink" title="8.5 常规包与命名空间包"></a>8.5 常规包与命名空间包</h3><p>常规包就是目录下有<code>__init__.py</code>的文件夹<br>命名空间包是特殊的封装设计，为合并不同的目录的代码到一个共同的命名空间（不能有<code>__init__.py</code>）</p>
<h3 id="8-6-导包技巧"><a href="#8-6-导包技巧" class="headerlink" title="8.6 导包技巧"></a>8.6 导包技巧</h3><p><code>importlib</code>专门用来导包的库</p>
<p>有一个包叫<code>import_from_github_com</code>，可以从github上远程下载并导包<br>原理是使用<code>pip</code>安装包而已<br>需要额外安装这个包<br>并且要求pip版本较新<br>（可能能够用于<strong>远程包含恶意文件</strong>？）</p>
<hr>
<p>可以在模块中定义<strong>列表</strong>变量<code>__all__</code>的值<br>这样可以控制<code>from pkg import *</code>中<code>*</code>的指代<br>（不用一下子全部导入）<br>经常在一个包的<code>__init__.py</code>中出现</p>
<hr>
<p><code>sys.modules</code>是一个字典：{key: 模块名, value: 模块对象}<br>存放着当前命名空间所有已经导入的模块对象<br>因此一般不存在重复导入的问题</p>
<h3 id="8-8-pip使用技巧"><a href="#8-8-pip使用技巧" class="headerlink" title="8.8 pip使用技巧"></a>8.8 pip使用技巧</h3><p><code>pip list --outdated</code>：查找当前环境下能够更新的包</p>
<p><code>pip show pkg</code>：查询一个包的详细内容</p>
<p><code>pip install --no-index --find-links=/path pkg</code>：从本地<em>path</em>目录中安装<em>pkg</em>包</p>
<p><code>pip install --user pkg</code>：将包安装为当前用户（优先导入用户环境的包，再导入全局环境的包）</p>
<p><code>pip install --default-timeout=100 pkg</code>：安装时延长超时时间</p>
<p><code>pip install --upgrade pkg</code>：升级包</p>
<hr>
<p>二进制包的下载与安装</p>
<p>下载：<code>pip download --no-binary=:all: pkg</code></p>
<p>安装：<code>pip install pkg --no-binary</code></p>
<hr>
<p><code>pip.ini</code>文件是pip程序的配置文件，可以设置下载&#x2F;安装的代理服务器<br>（没有需自己创建）</p>
<p>样例</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[global]</span></span><br><span class="line"><span class="attr">index-url</span> = http://mirrors.aliyun.com/pypi/simple/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换成自己的代理地址，格式为：[user:passwd@]proxy.server:port</span></span><br><span class="line"><span class="attr">proxy</span>=http://xxx.xxx.xxx.xxx:<span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="section">[install]</span></span><br><span class="line"><span class="comment"># 设置成信任源，否则会有警告</span></span><br><span class="line"><span class="attr">trusted-host</span>=mirrors.aliyun.com</span><br></pre></td></tr></table></figure>

<h3 id="8-8-导入器"><a href="#8-8-导入器" class="headerlink" title="8.8 导入器"></a>8.8 导入器</h3><p>涉及到<strong>查找器</strong>、<strong>加载器</strong>啥的，估计八辈子用不到，占个位先</p>
<p>如果要实现自己的远程导包，估计可以看看</p>
<h3 id="8-12-distutils与setuptools"><a href="#8-12-distutils与setuptools" class="headerlink" title="8.12 distutils与setuptools"></a>8.12 distutils与setuptools</h3><p><code>distutils</code>是Python的一个标准库，官方的一个分发打包工具</p>
<p>精髓在于编写<code>setup.py</code>，一个模块分发与安装的指导文件</p>
<p>一般这样通过源码安装第三方模块：<code>python setup.py install</code></p>
<p><code>setuptools</code>是<code>distutils</code>的增强版</p>
<h3 id="8-13-源码包与二进制包的区别"><a href="#8-13-源码包与二进制包的区别" class="headerlink" title="8.13 源码包与二进制包的区别"></a>8.13 源码包与二进制包的区别</h3><p>源码包（本质上是一个压缩包）的安装过程：<br>解压 -&gt; 编译 -&gt; 安装<br>由于安装前需要编译，因此是跨平台的</p>
<p>二进制包省去了编译过程，直接解压安装，但是需要选择平台<br>常见的格式有<code>egg</code>、<code>wheel</code></p>
<p><code>wheel</code>比<code>egg</code>格式更新<br><code>wheel</code>包可以通过<code>pip</code>来安装，但是需要先安装<code>wheel</code>模块，再使用<code>pip</code>命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pip install wheel</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pip wheel --wheel-dir=/local/wheels pkg</span></span><br></pre></td></tr></table></figure>

<h3 id="8-15-setup-py的编写"><a href="#8-15-setup-py的编写" class="headerlink" title="8.15 setup.py的编写"></a>8.15 setup.py的编写</h3><p>pdf只讲了怎么打包和使用这个文件，其实没有具体讲怎么编写</p>
<p><del>没那么快用得到发包吧。。。</del></p>
<p>具体可以看<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_36338224/article/details/109539961">这里</a></p>
<p>供应链投毒相关：可能会写好恶意包然后在PyPi上发布</p>
<h2 id="第九章-调试技巧"><a href="#第九章-调试技巧" class="headerlink" title="第九章 调试技巧"></a>第九章 调试技巧</h2><p>这里主要涉及到PyCharm的调试技巧，VSCode的调试另外起笔记吧</p>
<p>一些PyCharm的快捷键</p>
<ul>
<li><code>Shift</code>+<code>F10</code>：运行脚本</li>
<li><code>Shift</code>+<code>F9</code>：调试脚本</li>
<li>双击<code>Shift</code>：在所有地方搜索</li>
<li><code>Ctrl</code>+<code>F</code>：在当前脚本搜索</li>
<li><code>Ctrl</code>+<code>F8</code>：在选中行处下断点</li>
</ul>
<h3 id="9-1-调试基础"><a href="#9-1-调试基础" class="headerlink" title="9.1 调试基础"></a>9.1 调试基础</h3><p><img src="/2022/09/28/%E3%80%8APython-Guide%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220917153412144.png" alt="image-20220917153412144"></p>
<p>这里不熟的有线程&#x2F;帧切换，好像也涉及到了函数层次，后面学多线程时可能会用到</p>
<p>调试按钮（从左到右依次介绍）：</p>
<ul>
<li>显示执行点 | <code>Alt</code>+<code>F10</code>：跳转到程序正在运行的地方</li>
<li>步过 | <code>F8</code>：遇到子函数时不会进入子函数内单步执行，而是将子函数整个执行完再停止</li>
<li>步入 | <code>F7</code>：遇到子函数就进入并且继续单步执行，有的会跳到源代码里面去执行</li>
<li>单步执行我的代码 | <code>Alt</code>+<code>Shift</code>+<code>F7</code>：遇到子函数就进入并且继续单步执行，不会进入到源码中</li>
<li>步出 | <code>Shitf</code>+<code>F8</code>：跳出当前函数体内，返回到调用此函数的地方</li>
<li>运行到光标处 | <code>Alt</code>+<code>F9</code>：运行到光标处，省得打断点</li>
<li>评估表达式 | <code>Alt</code>+<code>F8</code>：计算表达式，可以执行一些代码</li>
</ul>
<p>另外左边竖着那一排，</p>
<ul>
<li>重新运行此脚本</li>
<li>修改运行配置，给上形参、环境变量、改变解释器、修改解释器选项啥的</li>
<li><code>F9</code>：恢复程序运行（<strong>运行到下个断点</strong>）</li>
<li><code>Ctrl</code>+<code>F2</code>：结束程序</li>
<li>查看、修改所有断点信息</li>
<li>禁止断点生效（静音断点）</li>
</ul>
<p>基本就是：设置好断点，debug运行，然后<code>F8</code>单步调试，遇到想进入的函数<code>F7</code>进去，想出来在<code>Shift</code>+<code>F8</code>，跳过不想看的地方，直接设置下一个断点，然后<code>F9</code>过去</p>
<p>需要命令行参数的话，在这里加上</p>
<p><img src="/2022/09/28/%E3%80%8APython-Guide%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220919221632243.png" alt="image-20220919221632243"></p>
<p>上面的<code>环境</code>那一栏还可以很方便地切换解释器</p>
<h3 id="9-3-运行中进入调试模式"><a href="#9-3-运行中进入调试模式" class="headerlink" title="9.3 运行中进入调试模式"></a>9.3 运行中进入调试模式</h3><p>调试（<code>Shift</code>+<code>F9</code>）模式中点击这里可以调出调试控制台，可以像在Python Shell中一样进行调试</p>
<p><img src="/2022/09/28/%E3%80%8APython-Guide%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220919223127000.png" alt="image-20220919223127000"></p>
<p>同时可以对变量进行赋值以动态改变变量</p>
<p><img src="/2022/09/28/%E3%80%8APython-Guide%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220919223303618.png" alt="image-20220919223303618"></p>
<p>不过也可以不进入调试台，在变量窗口设置就是了</p>
<p><img src="/2022/09/28/%E3%80%8APython-Guide%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220919223419014.png" alt="image-20220919223419014"></p>
<p>进行评估表达式（<code>Alt</code>+<code>F8</code>）也可以</p>
<h3 id="9-5-命令行界面调试：pdb"><a href="#9-5-命令行界面调试：pdb" class="headerlink" title="9.5 命令行界面调试：pdb"></a>9.5 命令行界面调试：pdb</h3><p><code>pdb</code>是自带的一个调试程序，一般有两种使用方式</p>
<p>一种是在执行python脚本之前加上<code>-m pdb</code>参数，如<code>python -m pdb test.py</code><br>这样子一运行就会<strong>从第一行语句开始</strong>debug</p>
<p>另一种是在脚本里先<code>import pdb</code><br>然后在需要的地方的上一行加上<code>pdb.set_trace()</code><br>然后正常<code>python test.py</code>运行<br>就会自动运行<strong>到打断点的地方才开始调试</strong></p>
<hr>
<p>下面是进入<code>pdb</code>调试模式后的一些指令<br>其实可通过键入<code>help</code>查看所有指令</p>
<p>下面列列常用的命令</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>英文</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>n</td>
<td>next</td>
<td>单步调试</td>
</tr>
<tr>
<td>l</td>
<td>list</td>
<td>列出当前断点的源码</td>
</tr>
<tr>
<td>p</td>
<td>print</td>
<td>打印变量</td>
</tr>
<tr>
<td>s</td>
<td>step into</td>
<td>步入当前函数</td>
</tr>
<tr>
<td>r</td>
<td>return</td>
<td>运行完当前函数，返回结果</td>
</tr>
<tr>
<td>c</td>
<td>continue</td>
<td>运行到下一个断点处</td>
</tr>
<tr>
<td>b</td>
<td>break</td>
<td>设置断点</td>
</tr>
<tr>
<td>q</td>
<td>quit</td>
<td>退出程序</td>
</tr>
</tbody></table>
<p>再列列可能常用的命令</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>英文</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>args</td>
<td>列出当前函数的参数</td>
</tr>
<tr>
<td>pp</td>
<td>pprint</td>
<td>一种可视化更好的打印</td>
</tr>
<tr>
<td>j</td>
<td>jump</td>
<td>跳到指定行</td>
</tr>
<tr>
<td>cl</td>
<td>clear</td>
<td>清除断点</td>
</tr>
<tr>
<td>w</td>
<td>where</td>
<td>打印当前堆栈</td>
</tr>
<tr>
<td>u</td>
<td>up</td>
<td>执行跳转到当前堆栈的上一层</td>
</tr>
<tr>
<td>unt</td>
<td>until</td>
<td>行数递增执行(忽略循环和函数)</td>
</tr>
<tr>
<td>ll</td>
<td>longlist</td>
<td>列出更多的源码</td>
</tr>
<tr>
<td>run&#x2F;restart</td>
<td>run</td>
<td>重新debug</td>
</tr>
</tbody></table>
<p>具体测试略</p>
<h3 id="9-7-命令行界面调试：PySnopper"><a href="#9-7-命令行界面调试：PySnopper" class="headerlink" title="9.7 命令行界面调试：PySnopper"></a>9.7 命令行界面调试：PySnopper</h3><p>不自带，需要另外安装：<code>pip install pysnooper</code></p>
<p>特点是以函数为单位进行debug，使用方法就是在需要debug的函数定义前面加上这个装饰符<br><code>@pysnooper.snoop(output=&#39;/var/log/debug.log&#39;)</code><br>其中<code>output</code>指定了调试输出到的文件，不指定则默认输出到标准输出</p>
<p>功能有：</p>
<ul>
<li>输出<strong>代码片段</strong>、<strong>行号</strong>以及<strong>每一行何时调用</strong></li>
<li>输出函数<strong>内局部变量值</strong>的变化、<strong>变量新增&#x2F;修改</strong>情况</li>
<li><strong>返回值</strong></li>
<li>函数<strong>运行时间</strong></li>
</ul>
<hr>
<p>装饰语句一些参数的使用：</p>
<ul>
<li><code>output</code>：接收一个字符串，指定重输出目标</li>
<li><code>watch</code>：接收一个list，存放字符串，追踪指示的全局变量（有变化时将其输出）</li>
<li><code>watch_explode</code>：接收一个list，存放字符串，追踪除此之外的其他所有全局变量（有变化时将其输出）</li>
<li><code>prefix</code>：接收一个字符串，输出时带上该前缀</li>
<li><code>max_variable_length</code>：接收一个整形，修改输出的最大字符串长度（<code>None</code>为不截断）</li>
<li><code>thread_info</code>：接收<code>True</code>&#x2F;<code>False</code>，是否支持多线程调试</li>
</ul>
<h3 id="9-7-远程调试"><a href="#9-7-远程调试" class="headerlink" title="9.7 远程调试"></a>9.7 远程调试</h3><p>通过PyCharm进行，但一般用不到，先记着有这个东西</p>
<h2 id="第十章-并发编程"><a href="#第十章-并发编程" class="headerlink" title="第十章 并发编程"></a>第十章 并发编程</h2><h3 id="10-1-多线程与多进程"><a href="#10-1-多线程与多进程" class="headerlink" title="10.1 多线程与多进程"></a>10.1 多线程与多进程</h3><p><code>多线程</code>：交替执行，另一种意义上的串行<br><code>多进程</code>：并行执行，真正意义上的的并发</p>
<p>简单讨论几种密集任务：</p>
<ul>
<li><code>CPU密集型</code>：大量的如<code>1+1</code>这样的CPU计算任务</li>
<li><code>IO密集型</code>：大量的磁盘读写操作、网络通信操作或者是数据库IO操作等</li>
</ul>
<p>不同场景下的使用结论：</p>
<ul>
<li>单线程总是最慢的，多进程总是最快的</li>
<li>多线程适合在（网络）IO密集场景下使用，譬如爬虫、网站开发等</li>
<li>多进程适合在对CPU计算运算要求较高的场景下使用，譬如大数据分析，机器学习等</li>
<li>多进程需要CPU资源支持下才能体现优势</li>
</ul>
<h3 id="10-2-多线程创建"><a href="#10-2-多线程创建" class="headerlink" title="10.2 多线程创建"></a>10.2 多线程创建</h3><p>大体有两种方法：</p>
<ul>
<li>使用自带的内置模块<code>threading.Thread</code></li>
<li>编写一个继承自<code>threading.Thread</code>的类</li>
</ul>
<hr>
<p>使用自带的模块，<code>threading.Thread</code>一般接收两个参数</p>
<ul>
<li><code>target</code>：传入线程要运行的函数</li>
<li><code>args</code>：传入运行函数的参数，以元组形式传入（最后参数后面也要加逗号），没参数则不传入</li>
</ul>
<p>例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">name=<span class="string">&quot;Archeri&quot;</span></span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>, name)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">thread_01 = Thread(target=task)</span><br><span class="line">thread_01.start()</span><br><span class="line"></span><br><span class="line">thread_02 = Thread(target=task, args=(<span class="string">&quot;Marquee&quot;</span>,)) <span class="comment"># 参数最后有一个逗号</span></span><br><span class="line">thread_02.start()</span><br></pre></td></tr></table></figure>

<p>输出（顺序不一定严格）：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hello Archeri</span><br><span class="line">hello Marquee</span><br><span class="line">hello Marquee</span><br><span class="line">hello Archeri</span><br><span class="line">hello Archeri</span><br><span class="line">hello Marquee</span><br></pre></td></tr></table></figure>

<hr>
<p>也可以自己创建一个线程类，这种情况的可读性感觉会更高一些</p>
<p>要求：</p>
<ul>
<li>必须继承<code>threading.Thread</code>类</li>
<li>必须复写<code>run</code>方法，在这里写业务逻辑，在调用<code>start()</code>后调用</li>
</ul>
<p>例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span>(<span class="title class_ inherited__">Thread</span>):</span><br><span class="line">    M = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, <span class="built_in">type</span></span>):</span><br><span class="line">        <span class="comment"># super().__init__()必须写</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">type</span> = <span class="built_in">type</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.<span class="built_in">type</span> == <span class="string">&quot;add&quot;</span>:</span><br><span class="line">                MyThread.M += <span class="number">1</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;AddNum:&quot;</span>, MyThread.M)</span><br><span class="line">                time.sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">elif</span> <span class="variable language_">self</span>.<span class="built_in">type</span> == <span class="string">&quot;mul&quot;</span>:</span><br><span class="line">                MyThread.M *= <span class="number">2</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;MulNum:&quot;</span>, MyThread.M)</span><br><span class="line">                time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    thread_add = MyThread(<span class="string">&quot;add&quot;</span>)</span><br><span class="line">    thread_mul = MyThread(<span class="string">&quot;mul&quot;</span>)</span><br><span class="line"></span><br><span class="line">    thread_add.start()</span><br><span class="line">    thread_mul.start()</span><br></pre></td></tr></table></figure>

<p>输出结果根据线程运行顺序的不同，会有不同的结果：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PS D:<span class="keyword">\python</span><span class="built_in">_</span>work&gt;python test.py</span><br><span class="line">AddNum: 2</span><br><span class="line">MulNum: 4</span><br><span class="line">AddNum: 5</span><br><span class="line">MulNum: 10</span><br><span class="line">MulNum: 20</span><br><span class="line">AddNum: 21</span><br><span class="line">PS D:<span class="keyword">\python</span><span class="built_in">_</span>work&gt; <span class="built_in">&amp;</span> python test.py</span><br><span class="line">AddNum: 2</span><br><span class="line">MulNum: 4</span><br><span class="line">MulNum: 8</span><br><span class="line">AddNum: 9</span><br><span class="line">AddNum: 10</span><br><span class="line">MulNum: 20</span><br></pre></td></tr></table></figure>

<hr>
<p>线程类<code>Thread</code>的主要方法和属性</p>
<p><strong>方法</strong><br><code>start()</code>：启动线程<br><code>join()</code>：阻塞线程，待子线程结束后再往下执行<br><code>is_alive()</code>：判断线程是否在执行，是的话返回<code>True</code></p>
<p><strong>属性</strong><br><code>daemon</code>：设置线程是否随主线程退出而退出，默认为<code>False</code><br><code>name</code>：设置线程名</p>
<h3 id="10-3-线程中的锁机制"><a href="#10-3-线程中的锁机制" class="headerlink" title="10.3 线程中的锁机制"></a>10.3 线程中的锁机制</h3><p><strong>该节的代码可能会导致系统出问题，慎重运行</strong></p>
<p>Python的锁可以分成两种：</p>
<ol>
<li>互斥锁</li>
<li>可重入锁</li>
</ol>
<hr>
<p>简单的<strong>互斥锁</strong>的示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成全局唯一的锁对象</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"><span class="comment"># 获取锁，未获取则会阻塞程序，直到获取锁</span></span><br><span class="line">lock.acquire()</span><br><span class="line"><span class="comment"># 释放锁</span></span><br><span class="line">lock.release()</span><br></pre></td></tr></table></figure>

<p>其中<code>acquire</code>方法和<code>release</code>方法必须要成对出现，否则可能造成死锁</p>
<p>推荐使用上下文管理器来管理锁：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"><span class="keyword">with</span> lock:</span><br><span class="line">    <span class="comment"># do something</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p><code>with</code>语句在代码块前自动获取锁，结束后自动释放锁</p>
<hr>
<p><strong>可重入锁（RLock）</strong></p>
<p>有时候会出现同一线程中请求同一个锁的情况<br>这时候用普通的<code>Lock</code>就会出现死锁</p>
<p>所以这个时候就要用可重用锁<code>RLock</code>，只要在同一线程里就当作是同一个请求，以此重用锁</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">job</span>():</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    rlock = threading.RLock()</span><br><span class="line">    <span class="keyword">with</span> rlock:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">            <span class="keyword">with</span> rlock:</span><br><span class="line">                <span class="built_in">print</span>(n)</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=job)</span><br><span class="line">t1.start()</span><br></pre></td></tr></table></figure>

<hr>
<p>若涉及到多个线程请求多个锁，为了防止出现死锁，可以写一个<strong>辅助函数</strong>来对锁进行排序，例如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"></span><br><span class="line"><span class="comment">## Thread-local state to stored information on locks already acquired</span></span><br><span class="line">_local = threading.local()</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">acquire</span>(<span class="params">*locks</span>):</span><br><span class="line">    <span class="comment"># Sort locks by object identifier</span></span><br><span class="line">    locks = <span class="built_in">sorted</span>(locks, key=<span class="keyword">lambda</span> x: <span class="built_in">id</span>(x))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Make sure lock order of previously acquired locks is not violated</span></span><br><span class="line">    acquired = <span class="built_in">getattr</span>(_local,<span class="string">&#x27;acquired&#x27;</span>,[])</span><br><span class="line">    <span class="keyword">if</span> acquired <span class="keyword">and</span> <span class="built_in">max</span>(<span class="built_in">id</span>(lock) <span class="keyword">for</span> lock <span class="keyword">in</span> acquired) &gt;= <span class="built_in">id</span>(locks[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;Lock Order Violation&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Acquire all of the locks</span></span><br><span class="line">    acquired.extend(locks)</span><br><span class="line">    _local.acquired = acquired</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> lock <span class="keyword">in</span> locks: </span><br><span class="line">            lock.acquire()</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="comment"># Release locks in reverse order of acquisition</span></span><br><span class="line">        <span class="keyword">for</span> lock <span class="keyword">in</span> <span class="built_in">reversed</span>(locks):</span><br><span class="line">            lock.release()</span><br><span class="line">        <span class="keyword">del</span> acquired[-<span class="built_in">len</span>(locks):]</span><br></pre></td></tr></table></figure>

<p>之后要请求锁这样调用函数<code>acquire(a_lock)</code></p>
<h3 id="10-4-线程消息通信机制"><a href="#10-4-线程消息通信机制" class="headerlink" title="10.4 线程消息通信机制"></a>10.4 线程消息通信机制</h3><p>线程通信的方法大致有以下三种</p>
<ul>
<li><code>threading.Event</code></li>
<li><code>threading.Condition</code></li>
<li><code>queue.Queue</code></li>
</ul>
<h4 id="01-threading-Event"><a href="#01-threading-Event" class="headerlink" title="01. threading.Event"></a>01. threading.Event</h4><p><strong>threading.Event</strong>是一种简单的通信机制，也是一种通用的条件变量<br>多个线程可以<strong>等待某个事件的发生</strong>，之后被<strong>激活</strong></p>
<p>基本方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个Event</span></span><br><span class="line">event = threading.Event()</span><br><span class="line"><span class="comment"># 重置event，使得所有该event事件都处于待命状态</span></span><br><span class="line">event.clear()</span><br><span class="line"><span class="comment"># 等待接收event的指令，决定是否阻塞程序执行</span></span><br><span class="line">event.wait()</span><br><span class="line"><span class="comment"># 发送event指令，使所有设置该event事件的线程执行</span></span><br><span class="line">event.<span class="built_in">set</span>()</span><br></pre></td></tr></table></figure>

<p>例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span>(threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, event</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.event = event</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Thread: &#123;&#125; start at &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="variable language_">self</span>.name, time.ctime(time.time())))</span><br><span class="line">        <span class="comment"># 等待event.set()之后，才能往下执行</span></span><br><span class="line">        <span class="variable language_">self</span>.event.wait()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Thread: &#123;&#125; start at &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="variable language_">self</span>.name, time.ctime(time.time())))</span><br><span class="line"></span><br><span class="line">threads = []</span><br><span class="line">event = threading.Event()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义5个线程，注意使用同一个event</span></span><br><span class="line">[threads.append(MyThread(<span class="built_in">str</span>(i), event)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置event，使得event.wait()起到阻塞作用</span></span><br><span class="line">event.clear()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动所有线程</span></span><br><span class="line">[t.start() <span class="keyword">for</span> t <span class="keyword">in</span> threads]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;wait 5 seconds...&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;awake&quot;</span>)</span><br><span class="line">event.<span class="built_in">set</span>()</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread: 1 start at Mon Sep 26 19:38:27 2022</span><br><span class="line">Thread: 2 start at Mon Sep 26 19:38:27 2022</span><br><span class="line">Thread: 3 start at Mon Sep 26 19:38:27 2022</span><br><span class="line">Thread: 4 start at Mon Sep 26 19:38:27 2022</span><br><span class="line">Thread: 5 start at Mon Sep 26 19:38:27 2022</span><br><span class="line">wait 5 seconds...</span><br><span class="line">awake</span><br><span class="line">Thread: 3 start at Mon Sep 26 19:38:32 2022</span><br><span class="line">Thread: 1 start at Mon Sep 26 19:38:32 2022</span><br><span class="line">Thread: 2 start at Mon Sep 26 19:38:32 2022</span><br><span class="line">Thread: 5 start at Mon Sep 26 19:38:32 2022</span><br><span class="line">Thread: 4 start at Mon Sep 26 19:38:32 2022</span><br></pre></td></tr></table></figure>

<p>大致上就是，可以定义多个<code>Event</code>去设置不同的通信机制，也可以设定多个线程共用一个<code>Event</code><br>用<code>wait</code>方法卡住线程，<code>set</code>方法激活线程，<code>clear</code>方法重置线程</p>
<h4 id="02-threading-Condition"><a href="#02-threading-Condition" class="headerlink" title="02. threading.Condition"></a>02. threading.Condition</h4><p>基本上和<code>threading.Event</code>类似</p>
<p>基本方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个Condition</span></span><br><span class="line">cond = threading.Condition()</span><br><span class="line"><span class="comment"># 请求锁</span></span><br><span class="line">cond.acquire()</span><br><span class="line"><span class="comment"># 等待指令同时释放锁，直到调用notify方法才重新获取锁</span></span><br><span class="line">cond.wait()</span><br><span class="line"><span class="comment"># 发送指令，触发执行</span></span><br><span class="line">cond.notify()</span><br><span class="line"><span class="comment"># 释放锁</span></span><br><span class="line">cond.release()</span><br><span class="line"><span class="comment"># 注意acquire方法和release方法要成对出现</span></span><br></pre></td></tr></table></figure>

<p>一个捉迷藏的例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hider</span>(threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, cond, name</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.cond = cond</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.cond.acquire()             <span class="comment"># 1.请求锁</span></span><br><span class="line">        <span class="variable language_">self</span>.cond.wait()                <span class="comment"># 2.让对面先蒙上眼睛，释放锁</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>.name, <span class="string">&#x27;: 藏好了&#x27;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.cond.notify()              <span class="comment"># 6.藏好了，提醒对面开始抓</span></span><br><span class="line">        <span class="variable language_">self</span>.cond.wait()                <span class="comment"># 7.等他来抓，释放锁</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>.name, <span class="string">&#x27;: 寄&#x27;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.cond.notify()</span><br><span class="line">        <span class="variable language_">self</span>.cond.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Seeker</span>(threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, cond, name</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.cond = cond</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        time.sleep(<span class="number">1</span>)                   <span class="comment"># 确保先藏</span></span><br><span class="line">        <span class="variable language_">self</span>.cond.acquire()             <span class="comment"># 3.拿到鬼释放的锁</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>.name + <span class="string">&#x27;: 我瞎了&#x27;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.cond.notify()              <span class="comment"># 4.提醒鬼开始藏</span></span><br><span class="line">        <span class="variable language_">self</span>.cond.wait()                <span class="comment"># 5.让鬼去藏，释放锁</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>.name + <span class="string">&#x27;: 逮到&#x27;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.cond.notify()              <span class="comment"># 8.抓到了</span></span><br><span class="line">        <span class="variable language_">self</span>.cond.wait()</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>.name + <span class="string">&#x27;: 菜&#x27;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.cond.release()</span><br><span class="line"></span><br><span class="line">cond = threading.Condition()</span><br><span class="line">seeker = Seeker(cond, <span class="string">&quot;seeker&quot;</span>)</span><br><span class="line">hider = Hider(cond, <span class="string">&quot;hider&quot;</span>)</span><br><span class="line">hider.start()</span><br><span class="line">seeker.start()</span><br></pre></td></tr></table></figure>

<h4 id="03-queue-Queue"><a href="#03-queue-Queue" class="headerlink" title="03. queue.Queue"></a>03. queue.Queue</h4><p>线程之间最安全的通信方式可能就是使用<code>queue.Queue</code></p>
<p>一个<code>Queue</code>对象可以被多个线程共享<br>这些线程通过使用<code>put</code>方法和<code>get</code>方法向队列中发送和获取元素</p>
<p>基本方法</p>
	
		</div>
		
		<div id="current-post-cover" data-scr="/img/post-cover/Python.png"></div>

		<!-- relate post, comment...-->
		<div class="investment-container">
			<div class="investment-header">
				<div class="investment-title-1">
					<div class="on">相关文章</div>
					<div>评论</div>
					<!-- <div>分享</div> -->
				</div>
				<div class="investment-title-2">	            
					
	<span>
		<a id="totop-post-page">返回顶部</a>
		
			<a href="/2022/10/06/Web%E9%9D%B6%E5%9C%BA-Pikachu/" title="Web靶场-Pikachu" rel="prev">
				&laquo;上一篇
			</a>
		
		
			<a href="/2022/09/06/Python%E8%A3%85%E9%A5%B0%E5%99%A8/" title="Python装饰器" rel="next">
				下一篇&raquo;
			</a>
			
	</span>


      		
				</div>	
			</div>
			
			<div class="investment-content">
				<div class="investment-content-list">
					

<div class="relate-post">
	
		<ul>
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2022/09/06/Python%E8%A3%85%E9%A5%B0%E5%99%A8/" title="Python装饰器">
								Python装饰器			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								九月 6日, 2022				
							</p>
							<p class="relate-post-content">
								[NOTE] Python装饰器学习资料：

Python 函数装饰器
装饰器类
Python __call__()方法（详解版）

基本概念先建立一个观点：函数本质上是一个对象，可以赋值给其他变量加上()后就变成执行函数本身，并获得...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2022/09/06/Python%E8%A3%85%E9%A5%B0%E5%99%A8/" title="Python装饰器">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/post-cover/Python.png" alt="Python装饰器"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2023/07/07/Web%E6%BC%8F%E6%B4%9E%E6%95%B4%E7%90%86-SQLi/" title="Web漏洞整理-SQLi">
								Web漏洞整理-SQLi			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								七月 7日, 2023				
							</p>
							<p class="relate-post-content">
								[NOTE] SQLi前言主要是之前练习了很多靶场所设计到的SQLi的笔记都比较分散这里就系统地整理下，主要是整合到一起，方便以后查阅
整理自靶场练习Webgoat、pikachu、Web For Pentester、XVWA、sql...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2023/07/07/Web%E6%BC%8F%E6%B4%9E%E6%95%B4%E7%90%86-SQLi/" title="Web漏洞整理-SQLi">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/post-cover/WebVuln1.jpg" alt="Web漏洞整理-SQLi"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2023/06/17/Linux%E6%94%BB%E9%98%B2-%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E5%8F%8A%E7%97%95%E8%BF%B9%E9%9A%90%E8%97%8F/" title="Linux攻防-权限维持及痕迹隐藏">
								Linux攻防-权限维持及痕迹隐藏			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								六月 17日, 2023				
							</p>
							<p class="relate-post-content">
								零、Linux下的控守技术概述控守技术可以理解为权限维持技术，泛指攻击者获取目标机器的控制权限后，将该权限长久维持的技术和方法
这里主要分为两大类：

权限维持：能够在失去当前控制权限时，下次能更容易地重获权限的方法
痕迹隐藏：能够使...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2023/06/17/Linux%E6%94%BB%E9%98%B2-%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E5%8F%8A%E7%97%95%E8%BF%B9%E9%9A%90%E8%97%8F/" title="Linux攻防-权限维持及痕迹隐藏">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/post-cover/Linux企鹅.png" alt="Linux攻防-权限维持及痕迹隐藏"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2023/06/04/Web%E9%9D%B6%E5%9C%BA-upload-labs/" title="Web靶场-upload-labs">
								Web靶场-upload-labs			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								六月 4日, 2023				
							</p>
							<p class="relate-post-content">
								环境攻击机：kali 10.10.10.128靶机：Debian 11.1 x64 
Pass-01任务：上传一个webshell到服务器
直接怼，显示：

改成basic.jpg，点击上传后bp抓包，修改后缀为.php，上传成功了：...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2023/06/04/Web%E9%9D%B6%E5%9C%BA-upload-labs/" title="Web靶场-upload-labs">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/post-cover/default.jpg" alt="Web靶场-upload-labs"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2023/05/04/PHP-Web%E6%B8%97%E9%80%8F%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E9%AB%98%E5%8D%B1%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E4%BC%AA%E5%8D%8F%E8%AE%AE/" title="PHP-Web渗透中常见的高危函数以及伪协议">
								PHP-Web渗透中常见的高危函数以及伪协议			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								五月 4日, 2023				
							</p>
							<p class="relate-post-content">
								代码执行函数eval
代码：&lt;?php @eval($_GET[&#39;cmd&#39;]);?&gt;
利用：http://10.10.10.3/test.php?cmd=phpinfo();
assert
代码：&lt;?...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2023/05/04/PHP-Web%E6%B8%97%E9%80%8F%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E9%AB%98%E5%8D%B1%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E4%BC%AA%E5%8D%8F%E8%AE%AE/" title="PHP-Web渗透中常见的高危函数以及伪协议">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/post-cover/PHP.png" alt="PHP-Web渗透中常见的高危函数以及伪协议"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2023/05/01/Webshell%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/" title="Webshell流量分析">
								Webshell流量分析			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								五月 1日, 2023				
							</p>
							<p class="relate-post-content">
								菜刀一句话在这里：&lt;?php eval($_POST[&#39;myhack&#39;]) ?&gt;
用的某个工具包里的菜刀，流量如下：

agent有火狐5.0以及百度
连接密码开头，用了array_map封装命令执行函数，...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2023/05/01/Webshell%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/" title="Webshell流量分析">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/post-cover/oiiai.jpg" alt="Webshell流量分析"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2023/04/22/Redis-%E9%85%8D%E7%BD%AE-%E5%91%BD%E4%BB%A4-%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/" title="Redis-配置&命令&漏洞利用">
								Redis-配置&命令&漏洞利用			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								四月 22日, 2023				
							</p>
							<p class="relate-post-content">
								Redis配置路径：/etc/redis/redis.conf
允许远程主机访问数据库：NETWORK一栏，注释掉bind 127.0.0.1 ::1同时设置protected-mode no
说明是这样的：

意思是Redis仅允许...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2023/04/22/Redis-%E9%85%8D%E7%BD%AE-%E5%91%BD%E4%BB%A4-%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/" title="Redis-配置&命令&漏洞利用">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/post-cover/Redis.png" alt="Redis-配置&amp;命令&amp;漏洞利用"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2023/03/30/sqli-labs-Stacked-Injections/" title="sqli-labs Stacked Injections">
								sqli-labs Stacked Injections			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								三月 30日, 2023				
							</p>
							<p class="relate-post-content">
								[NOTE] sqli-labs Stacked Injections前言针对sqli-labs靶场的做题笔记
环境虚拟机环境攻击机：kali | 10.10.10.1靶机：Debian 11.1 | 10.10.10.3 | Apa...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2023/03/30/sqli-labs-Stacked-Injections/" title="sqli-labs Stacked Injections">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/post-cover/rickroll.jpg" alt="sqli-labs Stacked Injections"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2023/03/06/%E3%80%8A%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%85%8D%E5%A5%97%E5%AE%9E%E9%AA%8C/" title="《信息安全导论》配套实验">
								《信息安全导论》配套实验			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								三月 6日, 2023				
							</p>
							<p class="relate-post-content">
								&#x3D;&#x3D;目前只有前两大章的内容，第三章网络安全还没看&#x3D;&#x3D;
01_Environment_Variable_and_SetUIDTask 1: Manipulating Environment Var...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2023/03/06/%E3%80%8A%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%85%8D%E5%A5%97%E5%AE%9E%E9%AA%8C/" title="《信息安全导论》配套实验">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/post-cover/SEEDbooks.jpg" alt="《信息安全导论》配套实验"/>
							</a>
						</div>
					</li>												
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2023/02/28/%E3%80%8A%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%85%8D%E5%A5%97%E7%BB%83%E4%B9%A0%E4%B8%8E%E9%A2%98%E8%A7%A3/" title="《信息安全导论》配套练习与题解">
								《信息安全导论》配套练习与题解			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								二月 28日, 2023				
							</p>
							<p class="relate-post-content">
								&#x3D;&#x3D;目前只有前两大章的内容，最后一章网络安全还没看&#x3D;&#x3D;
01_Set-UID_ex
不可以，因为Bob own的Set-UID程序，运行时的有效uid是Bob

不行，还是因为有效uid为100...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2023/02/28/%E3%80%8A%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%85%8D%E5%A5%97%E7%BB%83%E4%B9%A0%E4%B8%8E%E9%A2%98%E8%A7%A3/" title="《信息安全导论》配套练习与题解">				
								
								<img class="lazy" src="/img/lazy.gif" data-src="/img/post-cover/SEEDbooks.jpg" alt="《信息安全导论》配套练习与题解"/>
							</a>
						</div>
					</li>												
			
		</ul>
	
</div>	
				</div>
				<div class="investment-content-list">
					<div class="layout-comment">

	

		

			<!-- gitalk comment -->
			<!-- show gitalk comment -->
<div id="gitalk-container"></div>

<!-- gitalk`s css & js -->
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<link rel="stylesheet" href="/css/comment.css">
<script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js"></script>
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<script type="text/javascript">

	(function gitalkComment(){
		//Thanks O-R
		//https://github.com/gitalk/gitalk/issues/102#issuecomment-382970552
		//去除尾部匹配正则数组的字符串  
		//Remove redundant characters
		String.prototype.trimEnd = function(regStr) {
			let result = this;
			if(regStr == undefined || regStr == null || regStr == "") {
				return result;
			}
			let array = regStr.split(',');

			if(array.length > 0) {

				let c = array.shift(), 
					str = this,
					i = str.length,
					rg = new RegExp(c),
					matchArr = str.match(rg);

				if(matchArr != undefined && matchArr != null && matchArr.length > 0) {
					let matchStr = matchArr[0].replace(/\\/g, "\\\\").replace(/\*/g, "\\*")
						.replace(/\+/g, "\\+").replace(/\|/g, "\\|")
						.replace(/\{/g, "\\{").replace(/\}/g, "\\}")
						.replace(/\(/g, "\\(").replace(/\)/g, "\\)")
						.replace(/\^/g, "\\^").replace(/\$/g, "\\$")
						.replace(/\[/g, "\\[").replace(/\]/g, "\\]")
						.replace(/\?/g, "\\?").replace(/\,/g, "\\,")
						.replace(/\./g, "\\.").replace(/\&/g, "\\&");
					matchStr = matchStr + '$';
					result = str.replace(new RegExp(matchStr), "");
				}

				if(array.length > 0) {
					return result.trimEnd(array.join())
				} else {
					return result;
				}
			}
		};

		//Create gitalk
		let gitalk = new Gitalk({
			clientID: 'Ov23liAb4iwJ1VAXeknf',
			clientSecret: 'dbb92e8b0d3419b2a395abc8331a12e38e330e6c',
			//id: window.location.pathname,
			//id: decodeURI(window.location.pathname),
			//id: (window.location.pathname).split("/").pop().substring(0, 49),
			id: decodeURI( md5( location.href.trimEnd('#.*$,\\?.*$,index.html$') ) ),
			repo: 'Blog-Gitalk',
			owner: 'ArcheriShade',
			admin: 'ArcheriShade',
			distractionFreeMode: 'true',
		})
		gitalk.render('gitalk-container');		
	})();
</script>

		
		
	

</div>
				</div>
				<!-- <div class="investment-content-list">
					<div class="layout-share">
	
	
		<div class="config-info">
			Please check the parameter of <b>comment</b> in config.yml of hexo-theme-Annie!
		</div>	
	
</div>


				</div> -->
			</div>	
		</div>
	</div>
</div>

<!-- show math formula -->



	 
	
<script src="/plugin/clipboard/clipboard.js"></script>

	<script>
		// Copy code !
	    function preprocessing() {
	        $("#article-content .highlight").each(function() {
	            $(this).wrap('<div id="post-code"></div>');
	        })

	        $("#article-content #post-code").each(function() {
	            $(this).prepend('<nav class="copy-nav"><span><i class="code-language"></i></span></nav>');
	        })

	        $("#article-content .copy-nav").each(function() {
	            let languageClass = $(this).next().attr('class'),
	                language = ((languageClass.length > 9) && (languageClass != null)) ? languageClass.substr(10) : "none"; //why 9? Need to check language?

	            $(this).find('.code-language').text(language);
	            $(this).append('<span class="copy-btn icon-paste"></span>');
	        });
	    }

		function copy() {
		    $('#article-content #post-code').each(function(i) {
		        let codeCopyId = 'codeCopy-' + i;

		        let codeNode = $(this).find('.code'),
		            copyButton = $(this).find('.copy-btn');

		        codeNode.attr('id', codeCopyId);
		        copyButton.attr('data-clipboard-target-id', codeCopyId);
		    })
   
			let clipboard = new ClipboardJS('.copy-btn', {
					target: function(trigger) {
						return document.getElementById(trigger.getAttribute('data-clipboard-target-id'));
					}
		      	});

			//pure js
			function showTooltip(elem, msg) {		   
				elem.setAttribute('aria-label', msg);
				elem.setAttribute('class', 'copy-btn icon-clipboard1');
				setTimeout(function() {
					elem.setAttribute('class', 'copy-btn icon-paste');
				}, 2000);
			}

			clipboard.on('success', function(e) {
			    e.clearSelection();
			    console.info('Action:', e.action);		   
			    console.info('Trigger:', e.trigger);
			    showTooltip(e.trigger, 'Copied!');   
			});
			
			clipboard.on('error', function(e) {
			    console.error('Action:', e.action);
			    console.error('Trigger:', e.trigger);
			});
		}
		
		(function copyCode(){
			if ($('.layout-post').length) {
			    preprocessing();
			    copy();
			} 
		})();
	</script>






<link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">


<script src="/plugin/fancybox/jquery.fancybox.js"></script>


<script type="text/javascript">
	(function gallerySet(){
		let titleID = $('.article-title a'),
			imageID = $('.article-content img'),
			videoID = $('.article-content video');
		
		let postTitle = titleID.text() ? titleID.text() : "No post title!";
		
		imageID.each(function() {
			let imgPath = $(this).attr('src'),
				imgTitle = $(this).attr('alt') ? $(this).attr('alt') : "No image description!";
		
			//给每个匹配的<img>元素打包, 即添加父元素<a>
			$(this).wrap('<a data-fancybox="gallery" data-caption="《 ' + postTitle + ' 》' + imgTitle + '"href="' + imgPath + '"> </a>');
		});
		
		videoID.each(function() {
			let videoPath = $(this).attr('src');
		
			//给每个匹配的<img>元素打包, 即添加父元素<a>
			$(this).wrap('<a data-fancybox href=" ' + videoPath + ' "> </a>');
		});
		
		//TODO：支持html5 video

		if($('#layout-post').length) {
			$('[data-fancybox="gallery"]').fancybox({
				loop: true,
				buttons: [
					"zoom",
					"share",
					"slideShow",
					"fullScreen",
					//"download",
					"thumbs",
					"close"
				],
				protect: true
			});
		}
	})();
</script>
		</main>

		<!--footer-->
		<footer>
	<div id="navigation-show">
		<ul id="global-nav">
	
		<li class="menu-home">
			<a href="/" class="menu-item-home" target="_blank">主页</a>
		</li>
		
	
		<li class="menu-archive">
			<a href="/archives" class="menu-item-archive" target="_blank">归档</a>
		</li>
		
	
		<li class="menu-categories">
			<a href="/categories" class="menu-item-categories" target="_blank">分类</a>
		</li>
		
	
		<li class="menu-tags">
			<a href="/tags" class="menu-item-tags" target="_blank">标签</a>
		</li>
		
	
		<li class="menu-about">
			<a href="/about" class="menu-item-about" target="_blank">关于</a>
		</li>
		
	
		<li class="menu-gallery">
			<a href="/gallery" class="menu-item-gallery" target="_blank">相册</a>
		</li>
		
	

	
		<li class="menu-search">
			<a href="javascript:;" class="popup-trigger">搜索</a>
		</li>
	
</ul>
	</div>

	<div class="copyright">
		<p>
			 
				&copy;2024, content by ArcheriShade. All Rights Reserved.
			
			
				<a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> Theme <a href="https://github.com/Sariay/hexo-theme-Annie" title="Annie" target="_blank" rel="noopener">Annie</a> by Sariay.
			
		</p>
		<p>
			

	<!-- busuanzi -->
	<!-- busuanzi -->



			<a href="javascript:zh_tran('s');" class="zh_click" id="zh_click_s">简体</a> 
			<a href="javascript:zh_tran('t');" class="zh_click" id="zh_click_t">繁體</a>				
		</p>
	</div>		
</footer>
		
	<!-- Local or hitokoto! -->

	
<script src="/plugin/motto/motto.js"></script>

	
	<script type="text/javascript">
		(function motto(){
			let mottoText = getMingYanContent().split('</br> - </br>'),
			
			mottoTextContent = mottoText[0]?mottoText[0]:'请刷新...',
			
			mottoTextFrom = mottoText[1]?mottoText[1]:'one/一个';
			
			mottoTextContent = mottoTextContent.trim().substring(0, 100);
		
			$("#motto-content").html( mottoTextContent);
			$("#motto-author").html( mottoTextFrom  );
		})();	
	</script>	



<!-- love effect -->


<!-- back to top -->

	<div id="totop">
	<span class="icon-circle-up"></span>
</div>



<!-- site analysis -->


	<!-- site-analysis -->
	
	
	
	
	
 

<!-- leancloud -->


	<!-- leancloud -->
	<!--
	时间：2018-11-27
	描述：
		文章访问量：visitors
		文章喜欢量：likes	
		文章排行榜：topNPost
		其他得说明：
			01-Cookie相关的函数 
				https://blog.csdn.net/somehow1002/article/details/78511541（Author：somehow1002）
			02-visitors相关的函数 
				https://blog.csdn.net/u013553529/article/details/63357382（Author：爱博客大伯）
				https://notes.doublemine.me/2015-10-21-为NexT主题添加文章阅读量统计功能.html（Author：夏末）
			03-topNPost相关的函数
				https://hoxis.github.io/hexo-next-read-rank.html（Author：hoxis）
			04-likes相关的函数，
				参考了01 & 02进行简单的设计与实现
-->


	

  

	<!--
	时间：2018-10-3
	描述：
		插件名称：hexo-generator-search-zip
		插件来源: https://github.com/SuperKieran/hexo-generator-search-zip
		代码参考：https://github.com/SuperKieran/TKL/blob/master/layout/_partial/search.ejs(Include: js & css)	
-->
<div class="popup search-popup local-search-popup scrollbar" >
	<div class="local-search-container">
		<span class="popup-btn-close">
      		ESC
   		</span>
		<div class="local-search-header">
			<div class="input-prompt">				
			</div>
			<input autocomplete="off" placeholder="Search..." type="text" id="local-search-input">
		</div>
		<div class="local-search-body">
			<div id="local-search-output"></div>
		</div>
		<div class="local-search-footer">
			<div class="topN-post">				
				
								
			</div>
		</div>
	</div>
</div>


<script src="/plugin/search/ziploader.js"></script>
<script src="/js/search.js"></script>


<script type="text/javascript">
	var search_path = 'search.json',
		zip_Path = '/search.zip',
		version_Path = '/searchVersion.txt',
		input_Trigger = 'auto',
		top_N = '2';

	themeLocalSearch({
		search_path, 
		zip_Path, 
		version_Path, 
		input_Trigger, 
		top_N
	});
</script>



<script src="/plugin/chinese/chinese.js"></script>
<script src="/plugin/imagelazyloader/yall.min.js"></script>
<script src="/plugin/imageloaded/imagesloaded.pkgd.min.js"></script>
<script src="/plugin/nicescroll/jquery.nicescroll.js"></script>
<script src="/plugin/resizediv/resizediv.js"></script>
<script src="/js/main.js"></script>

	</body>	
</html>